# app/core/citation_parser.py

import re
import logging
from typing import List, Dict, Any, Optional

logger = logging.getLogger(__name__)

# Define the expected citation pattern
# Group 1: Full marker content (e.g., "OriginalFileName.ext:PageNumber")
# Group 2: Filename (e.g., "OriginalFileName.ext")
# Group 3: Optional page number (e.g., ":PageNumber")
# Group 4: Just the page number (e.g., "PageNumber")
CITATION_PATTERN = re.compile(r'\[↩:(.+?)\]')  # Matches [↩:SomeSource.pdf:123] or [↩:SomeDoc.txt]


def extract_citations_from_text(
        llm_response_text: str,
        retrieved_documents_metadata: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """
    Extracts citation markers from the LLM's response text and maps them
    to the metadata of the retrieved documents.

    Args:
        llm_response_text: The raw text generated by the LLM.
        retrieved_documents_metadata: A list of dictionaries, where each dict contains
                                      the metadata of a chunk that was sent to the LLM.
                                      Expected keys: 'doc_name', 'page_number' (optional), 'temp_doc_id'.

    Returns:
        A list of dictionaries, each representing a found citation:
        {
            "marker_text": "[↩:Source.pdf:5]",  # The full citation string found in the text
            "doc_name": "Source.pdf",           # Extracted document name
            "page": 5,                          # Extracted page number (or None)
            "temp_doc_id": "uuid-of-temp-doc",  # Mapped temporary document ID (or None if not found)
            "start_char": 100,                  # Start index of the marker in llm_response_text
            "end_char": 115                     # End index of the marker in llm_response_text
        }
    """
    citations_found = []

    # Create a mapping for efficient lookup of retrieved documents by name/page
    # Format: {"filename_page": [temp_doc_id, ...], "filename_only": [temp_doc_id, ...]}
    doc_lookup = {}
    for doc_meta in retrieved_documents_metadata:
        doc_name = doc_meta.get('doc_name')
        page_number = doc_meta.get('page_number')
        temp_doc_id = doc_meta.get('temp_doc_id')

        if not doc_name or not temp_doc_id:
            continue  # Skip if essential metadata is missing

        # Add to lookup by full identifier (name + page)
        if page_number is not None:
            key_with_page = f"{doc_name.lower()}:{page_number}"
            if key_with_page not in doc_lookup:
                doc_lookup[key_with_page] = []
            doc_lookup[key_with_page].append(temp_doc_id)

        # Add to lookup by name only (for citations without page numbers)
        key_only_name = doc_name.lower()
        if key_only_name not in doc_lookup:
            doc_lookup[key_only_name] = []
        doc_lookup[key_only_name].append(temp_doc_id)

    # Use a set to avoid duplicate citations (e.g., if LLM cites the same source multiple times)
    processed_citation_markers = set()

    for match in CITATION_PATTERN.finditer(llm_response_text):
        full_marker_text = match.group(0)  # e.g., "[↩:Source.pdf:5]"
        inner_content = match.group(1)  # e.g., "Source.pdf:5" or "Source.pdf"
        start_char, end_char = match.span()

        # Avoid processing the same marker text multiple times if there are overlaps or duplicates
        if full_marker_text in processed_citation_markers:
            continue
        processed_citation_markers.add(full_marker_text)

        # Parse the inner content
        parts = inner_content.split(':')
        extracted_doc_name = parts[0].strip()
        extracted_page_number = None
        if len(parts) > 1:
            try:
                # Attempt to extract page number, it might be "Page 5" or "5"
                page_part = parts[1].strip()
                extracted_page_number = int(re.search(r'\d+', page_part).group(0))
            except (ValueError, AttributeError):
                extracted_page_number = None  # Not a valid number

        # Map to retrieved documents using the lookup
        matched_temp_doc_id = None
        matched_doc_name = extracted_doc_name  # Assume this unless a better match is found
        matched_page = extracted_page_number

        # Try matching with page number first
        if extracted_page_number is not None:
            lookup_key_with_page = f"{extracted_doc_name.lower()}:{extracted_page_number}"
            if lookup_key_with_page in doc_lookup:
                # Take the first temp_doc_id for simplicity; ideally, check for uniqueness or handle multiple
                matched_temp_doc_id = doc_lookup[lookup_key_with_page][0]

                # If no match with page, try matching with just the document name
        if matched_temp_doc_id is None:
            lookup_key_only_name = extracted_doc_name.lower()
            if lookup_key_only_name in doc_lookup:
                matched_temp_doc_id = doc_lookup[lookup_key_only_name][0]
                # If matched by name only, and LLM provided a page, keep that page.
                # If LLM didn't provide a page, `matched_page` remains None.

        if matched_temp_doc_id:
            citations_found.append({
                "marker_text": full_marker_text,
                "doc_name": matched_doc_name,
                "page": matched_page,
                "temp_doc_id": matched_temp_doc_id,
                "start_char": start_char,
                "end_char": end_char
            })
        else:
            logger.warning(f"Could not map citation marker '{full_marker_text}' to a retrieved document.")
            # Optionally add unmapped citations with temp_doc_id=None or some error flag
            citations_found.append({
                "marker_text": full_marker_text,
                "doc_name": matched_doc_name,
                "page": matched_page,
                "temp_doc_id": None,  # Indicate no match
                "start_char": start_char,
                "end_char": end_char
            })

    return citations_found