<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>RAGnetic Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.7/dist/purify.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=JetBrains+Mono&display=swap" rel="stylesheet" />
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', path='css/style.css') }}">
    <script src="{{ url_for('static', path='js/ingestion_modal_logic.js') }}" defer></script>
    <script src="{{ url_for('static', path='js/chat_quick_upload.js') }}" defer></script>
    <script src="{{ url_for('static', path='js/citation_renderer.js') }}" defer></script>
</head>
<body>
    <div id="toast-notification"></div>
    <div id="confirmation-modal">
        <div class="modal-content">
            <p id="modal-text">Are you sure?</p>
            <div class="modal-buttons">
                <button id="modal-cancel-btn" class="modal-btn cancel">Cancel</button>
                <button id="modal-confirm-btn" class="modal-btn confirm">Confirm</button>
            </div>
        </div>
    </div>

    <div id="ingestion-modal" class="modal">
    </div>
    <aside id="chat-history-sidebar">
        <div class="sidebar-top">
            <button id="new-chat-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                <span>New Chat</span>
            </button>
            <select id="agent-select" name="agent">
                {% for a in agents %}
                <option value="{{ a.name }}" {% if a.name == agent %}selected{% endif %}>{{ a.display_name }}</option>
                {% endfor %}
            </select>
            <button id="open-ingestion-modal-btn">
                 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-database"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M3 5V19A9 3 0 0 0 21 19V5"/><path d="M3 12A9 3 0 0 0 21 12"/><path d="M3 19A9 3 0 0 0 21 19"/></svg>
                <span>Ingest Data</span>
            </button>
        </div>
        <h3 class="history-heading">Recent</h3>
        <ul id="history-list"></ul>
        <button id="logout-btn" style="width: 90%; margin: 10px auto; display: block; padding: 10px 15px; border: none; border-radius: 5px; background-color: #f44336; color: white; cursor: pointer; font-size: 1em;">Logout</button>
    </aside>
    <div id="chat-container">
        <div id="messages"></div>

        <div id="citation-popup" class="citation-popup"></div>

        <div id="quickUploadFileList" class="attachment-list"></div>
        <div id="input-form-container">
            <div id="typing-indicator" style="opacity: 0; display:none;">
                <div class="pulsing-dot"></div>
                <span>RAGnetic is thinking...</span>
            </div>
            <form id="input-form" onsubmit="handleFormSubmit(event)">
                <button type="button" id="quickUploadBtn" title="Attach file">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/></svg>
                </button>
                <input type="file" id="quickUploadFileInput" multiple style="display: none;">
                <textarea name="query" id="query-input" placeholder="Ask RAGneticâ€¦" rows="1"></textarea>
                <button type="submit" id="send-stop-btn">
                    <span id="send-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" /></svg></span>
                    <span id="stop-icon" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M6 6h12v12H6V6z"></path></svg></span>
                </button>
            </form>
            <p class="disclaimer-text">RAGnetic can make mistakes. Double check your source.</p>
        </div>
    </div>
<script>
    // These are global variables used by ingestion_modal_logic.js and other modules
    const API_BASE_URL = window.location.origin + '/api/v1';
    let loggedInUserToken = localStorage.getItem('ragnetic_user_token');
    let loggedInDbUserId = localStorage.getItem('ragnetic_db_user_id');

    const agentSelect = document.getElementById('agent-select');
    const messagesDiv = document.getElementById('messages');
    const inputField = document.getElementById('query-input');
    const sendStopButton = document.getElementById('send-stop-btn');
    const sendIcon = document.getElementById('send-icon');
    const stopIcon = document.getElementById('stop-icon');
    const typingIndicator = document.getElementById('typing-indicator');
    const newChatButton = document.getElementById('new-chat-btn');
    const toastNotification = document.getElementById('toast-notification');
    const confirmationModal = document.getElementById('confirmation-modal');
    const modalText = document.getElementById('modal-text');
    const modalConfirmBtn = document.getElementById('modal-confirm-btn');
    const modalCancelBtn = document.getElementById('modal-cancel-btn');

    const historySidebar = document.getElementById('chat-history-sidebar');
    const chatContainer = document.getElementById('chat-container');
    const historyList = document.getElementById('history-list');
    const logoutBtn = document.getElementById('logout-btn');

    // Ingestion Modal elements (main container and trigger button)
    const ingestionModal = document.getElementById('ingestion-modal');
    const openIngestionModalBtn = document.getElementById('open-ingestion-modal-btn');

    // Quick Upload Elements (from chat_quick_upload.js context, accessed globally here)
    const quickUploadBtn = document.getElementById('quickUploadBtn');
    const quickUploadFileInput = document.getElementById('quickUploadFileInput');
    const quickUploadFileList = document.getElementById('quickUploadFileList');


    let agent, thread_id, socket;
    let confirmCallback = null;
    let isGenerating = false;
    const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
    const WS_URL = `${protocol}://${location.host}/ws`;

    const svgs = {
        copy: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M7.5 3a.75.75 0 00-.75.75v13.5a.75.75 0 00.75.75h9a.75.75 0 00.75-.75V3.75A.75.75 0 0016.5 3h-9zM8.25 4.5h7.5v12h-7.5V4.5z" /><path d="M6 1.5a.75.75 0 00-.75.75V16.5a.75.75 0 00.75.75h.008a.75.75 0 00.75-.75V2.25A.75.75 0 006.008 1.5H6z" /></svg>`,
        copied: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path fill-rule="evenodd" d="M19.916 4.626a.75.75 0 01.208 1.04l-9 13.5a.75.75 0 01-1.154.114l-6-6a.75.75 0 011.06-1.06l5.353 5.353 8.493-12.739a.75.75 0 011.04-.208z" clip-rule="evenodd" /></svg>`,
        copyCode: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg>`,
        copiedCode: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 010-1.06.733.733 0 011.047 0l3.052 3.093 5.4-6.425a.247.247 0 01.02-.022z"/></svg>`
    };
    function renderMath(element) { if (window.MathJax) { window.MathJax.typesetPromise(element ? [element] : []).catch((err) => console.error('MathJax typesetting error:', err)); } }
    function showToast(message, isError = false) { toastNotification.textContent = message; toastNotification.className = isError ? 'error' : 'success'; toastNotification.style.display = 'block'; setTimeout(() => { toastNotification.style.display = 'none'; }, 4000); }
    function scrollToBottom() { window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' }); }

        function setGeneratingState(generating) {
            isGenerating = generating;
            sendIcon.style.display = generating ? 'none' : 'inline';
            stopIcon.style.display = generating ? 'inline' : 'none';
            inputField.disabled = generating;
            sendStopButton.classList.toggle('stop-active', generating);
            quickUploadBtn.disabled = generating;
            if (!generating) {
                typingIndicator.style.display = 'none';
                inputField.focus();
            }
        }
    function renderEmptyState() { messagesDiv.innerHTML = `<div id="empty-state"><h1>RAG<span>netic</span></h1><p>Your on-premise AI assistant. Select an agent and ask a question to begin.</p></div>`; }

    function setupChatEnvironment() {
        const savedAgent = localStorage.getItem('ragnetic_agent');
        if (savedAgent) {
            agentSelect.value = savedAgent;
        }
        agent = agentSelect.value;
        thread_id = localStorage.getItem('ragnetic_thread_id');

        if (thread_id) {
            loadHistory(agent, thread_id, loggedInDbUserId);
        } else {
            renderEmptyState();
        }
        fetchChatSessions(agent);
        openWebSocket();
    }


function normalizeMD(s) {
  return (s || '').replace(/\r\n/g, '\n').trim();
}

function hydrateCitationsForBubble(bubble, citations) {
  if (!bubble || bubble.dataset.citationsHydrated === 'true') return;
  if (!Array.isArray(citations) || citations.length === 0) return;
  if (!window.citationRenderer?.renderCitations) return;
  window.citationRenderer.renderCitations(bubble, citations);
  window.citationRenderer?.prefetch?.(citations);
  bubble.dataset.citationsHydrated = 'true';
}

async function backfillCitationsForBubbles(bubbles) {
  try {
    // Ensure renderer is ready (in case script is still loading)
    if (!window.citationRenderer?.renderCitations) {
      await new Promise(r => setTimeout(r, 30));
      if (!window.citationRenderer?.renderCitations) return;
    }

    const resp = await fetch(`/history/${thread_id}?agent_name=${agent}&user_id=${loggedInDbUserId}`, {
      headers: { 'X-API-Key': loggedInUserToken }
    });
    if (!resp.ok) return;

    const history = await resp.json();

    // Build a lookup: normalized markdown -> citations (prefer latest occurrence)
    const map = new Map();
    for (let i = history.length - 1; i >= 0; i--) {
      const m = history[i];
      if (m.type === 'ai' && m.content) {
        const cites = m.meta?.citations || [];
        if (cites.length && !map.has(normalizeMD(m.content))) {
          map.set(normalizeMD(m.content), cites);
        }
      }
    }

    bubbles.forEach(b => {
      if (b.dataset.citationsHydrated === 'true') return;
      const md = normalizeMD(b.dataset.rawMarkdown || '');
      const cites = map.get(md);
      if (cites) hydrateCitationsForBubble(b, cites);
    });
  } catch (e) {
    console.warn('Citation backfill failed:', e);
  }
}

    function openWebSocket(onOpenCallback) {
        if (socket && socket.readyState !== WebSocket.CLOSED) { socket.close(1000, "Starting new session"); }
        let wsUrl = `${protocol}://${location.host}/ws`;
        if (loggedInUserToken) {
            wsUrl += `?api_key=${loggedInUserToken}`;
        }
        socket = new WebSocket(wsUrl);
        socket.onopen = () => { sendStopButton.disabled = false; quickUploadBtn.disabled = false; if (onOpenCallback) { onOpenCallback(); } };
        socket.onerror = (event) => { console.error("WebSocket error:", event); showToast("Connection error. Check console for details.", true); };
        socket.onclose = (event) => {
            sendStopButton.disabled = true;
            quickUploadBtn.disabled = true;
            if (isGenerating) setGeneratingState(false);
            if (event.code === 1008) { showToast("Connection rejected: Invalid or missing API Key.", true); }
            else if (event.code !== 1000) { showToast(`WebSocket disconnected: Code ${event.code}`, true); }
            else {
                if (!loggedInUserToken || !loggedInDbUserId) {
                    window.location.href = '/login';
                }
            }
        };
socket.onmessage = async (event) => {

  const data = JSON.parse(event.data);

  if (data.token) {
    typingIndicator.style.display = 'none';
    appendAgentToken(data.token);
  }

  if (data.done) {
    setGeneratingState(false);

    if (data.user_id && data.user_id !== loggedInDbUserId) {
      loggedInDbUserId = data.user_id;
      localStorage.setItem('ragnetic_db_user_id', loggedInDbUserId);
    }
    thread_id = data.thread_id;
    localStorage.setItem('ragnetic_thread_id', thread_id);
    localStorage.setItem('ragnetic_agent', agent);
    fetchChatSessions(agent);

    const lastMessage = messagesDiv.lastElementChild;
    if (!lastMessage) {
      console.warn("Could not find streaming agent message to finalize.");
      return;
    }

        lastMessage.dataset.streaming = 'false';
        lastMessage.classList.remove('streaming-agent-message');

        const contentDiv = lastMessage.querySelector('.content');
        contentDiv.innerHTML = DOMPurify.sanitize(marked.parse(lastMessage.dataset.rawMarkdown));

        // 1) Code blocks
        renderCodeblocks(lastMessage);

        // 2) Hydrate citations once per bubble (avoid double rendering)
        if (!lastMessage.dataset.citationsHydrated) {
          if (Array.isArray(data.citations) && data.citations.length) {
            hydrateCitationsForBubble(lastMessage, data.citations);
          } else {
            await backfillCitationsForBubbles([lastMessage]); // match by content
          }
        }

        // 3) Math after citations
        renderMath(lastMessage);

        // (nice-to-have) keep the view pinned
        scrollToBottom();

              }
    };
   }
    function handleFormSubmit(event) {
        if (event) event.preventDefault();
        if (isGenerating) {
            socket.send(JSON.stringify({ type: 'interrupt' }));
            setGeneratingState(false);
        } else {
            sendMessage();
        }
    }
    async function sendMessage() {
        if (!loggedInUserToken || !loggedInDbUserId) {
            showToast("Please log in to chat.", true);
            return;
        }
        const query = inputField.value.trim();
        const attachedFiles = window.quickUploads.getAttachedFiles();
        if (!query && attachedFiles.length === 0) {
            showToast("Please enter a query or attach files.", true);
            return;
        }
        setGeneratingState(true);
        typingIndicator.style.opacity = '1';
        typingIndicator.style.display = 'flex';
        scrollToBottom();
        const uploadedFileInfos = [];
        if (attachedFiles.length > 0) {
            appendUserMessage("Uploading files...");
            try {
                if (!thread_id) {
                    const sessionCreationPayload = {
                        agent_name: agent,
                        user_id: parseInt(loggedInDbUserId)
                    };
                    const sessionResponse = await fetch(`${API_BASE_URL}/sessions/create`, {
                        method: 'POST',
                        headers: {
                            'X-API-Key': loggedInUserToken,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(sessionCreationPayload)
                    });
                    if (!sessionResponse.ok) {
                        const errorText = await sessionResponse.text();
                        throw new Error(`Failed to create new session for file upload: ${sessionResponse.status} - ${errorText}`);
                    }
                    const sessionData = await sessionResponse.json();
                    thread_id = sessionData.thread_id;
                    localStorage.setItem('ragnetic_thread_id', thread_id);
                    showToast("New chat session created for file upload.", false);
                    fetchChatSessions(agent);
                }
                const uploadPromises = attachedFiles.map(file =>
                    window.quickUploads.uploadFileToBackend(file, thread_id)
                );
                const results = await Promise.all(uploadPromises);
                uploadedFileInfos.push(...results);
                appendUserMessage("Files uploaded successfully. Processing query...");
            } catch (error) {
                setGeneratingState(false);
                showToast(`File upload pre-processing failed: ${error.message}`, true);
                return;
            }
        }
        const payload = {
            agent,
            user_id: parseInt(loggedInDbUserId),
            thread_id,
            query,
            files: uploadedFileInfos
        };
        const message = { type: 'query', payload: payload };
        const doSend = () => {
            socket.send(JSON.stringify(message));
            const emptyState = document.getElementById('empty-state');
            if (emptyState) emptyState.remove();
            appendUserMessage(query);
            if (uploadedFileInfos.length > 0) {
                appendAttachedFilesToUserMessage(uploadedFileInfos);
            }
            inputField.value = '';
            inputField.style.height = 'auto';
            window.quickUploads.clearAttachedFiles();
        };
        if (!socket || socket.readyState !== WebSocket.OPEN) {
            showToast("Connecting... Please try again shortly.");
            openWebSocket(doSend);
        } else {
            doSend();
        }
    }
    function appendUserMessage(text) {
        const msg = document.createElement('div');
        msg.className = 'message user';
        msg.textContent = text;
        messagesDiv.appendChild(msg);
        scrollToBottom();
    }
    function appendAttachedFilesToUserMessage(uploadedFileInfos) {
        const lastUserMessage = messagesDiv.lastElementChild;
        if (lastUserMessage && lastUserMessage.classList.contains('user')) {
            const attachmentsDiv = document.createElement('div');
            attachmentsDiv.className = 'user-message-attachments';
            uploadedFileInfos.forEach(fileInfo => {
                const fileSpan = document.createElement('span');
                fileSpan.className = 'attached-file-display';
                fileSpan.textContent = fileInfo.file_name;
                attachmentsDiv.appendChild(fileSpan);
            });
            lastUserMessage.appendChild(attachmentsDiv);
            scrollToBottom();
        }
    }

    /**
     * Creates a new message bubble for AI responses.
     * REMOVED: `sources-button` creation.
     */
    function createAgentMessageBubble() {
        const bubble = document.createElement('div');
        bubble.className = 'message agent';
        bubble.dataset.rawMarkdown = '';
        bubble.dataset.messageId = '';

        const contentDiv = document.createElement('div');
        contentDiv.className = 'content';
        bubble.appendChild(contentDiv);

        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.innerHTML = svgs.copy;
        copyBtn.addEventListener('click', () => {
            const md = bubble.dataset.rawMarkdown;
            if (!md) return;
            navigator.clipboard.writeText(md)
                .then(() => {
                    copyBtn.innerHTML = svgs.copied;
                    setTimeout(() => {
                        copyBtn.innerHTML = svgs.copy;
                    }, 2000);
                });
        });
        bubble.appendChild(copyBtn);

        messagesDiv.appendChild(bubble);

        return bubble;
    }
    function renderCodeblocks(scopeElement) {
        scopeElement.querySelectorAll('pre > code').forEach((codeBlock) => {
            const pre = codeBlock.parentElement;
            if (pre.querySelector('.code-header')) return;
            const lang =
          [...(codeBlock.classList || [])]
            .find(c => c.startsWith('language-'))
            ?.slice('language-'.length) || 'text';
            const header = document.createElement('div');
            header.className = 'code-header';
            const langSpan = document.createElement('span');
            langSpan.textContent = lang;
            const copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.innerHTML = svgs.copyCode;
            copyBtn.onclick = () => {
                navigator.clipboard.writeText(codeBlock.textContent).then(() => {
                    copyBtn.innerHTML = svgs.copiedCode;
                    setTimeout(() => {
                        copyBtn.innerHTML = svgs.copyCode;
                    }, 2000);
                });
            };
            header.appendChild(langSpan);
            header.appendChild(copyBtn);
            pre.insertBefore(header, codeBlock);
        });
    }
        let rafScheduled = false;

        function appendAgentToken(token) {
          let lastMessage = messagesDiv.lastElementChild;
          if (lastMessage?.dataset?.streaming === 'false') return;

          if (!lastMessage || !lastMessage.classList.contains('agent')) {
            typingIndicator.style.display = 'none';
            lastMessage = createAgentMessageBubble();
            lastMessage.dataset.streaming = 'true';
            lastMessage.classList.add('streaming-agent-message');
          }

          lastMessage.dataset.rawMarkdown += token;
          const contentDiv = lastMessage.querySelector('.content');

          if (!rafScheduled && contentDiv) {
            rafScheduled = true;
            requestAnimationFrame(() => {
              const rawHtml = marked.parse(lastMessage.dataset.rawMarkdown);
              contentDiv.innerHTML = DOMPurify.sanitize(rawHtml);
              renderCodeblocks(contentDiv);
              scrollToBottom();
              rafScheduled = false;
            });
          }
        }
    async function loadHistory(agentName, threadId, userId) {
  if (!loggedInUserToken || !loggedInDbUserId) {
    showToast("Cannot load history: Not logged in.", true);
    return;
  }
  try {
    const response = await fetch(`/history/${threadId}?agent_name=${agentName}&user_id=${loggedInDbUserId}`, {
      method: 'GET',
      headers: { 'X-API-Key': loggedInUserToken }
    });

    if (!response.ok) {
      if (response.status === 404) {
        console.warn(`History for thread ${threadId} not found or unauthorized.`);
        startNewSession(false);
        return;
      }
      showToast(`Could not load session (status: ${response.status}).`, true);
      return;
    }

    const history = await response.json();
    messagesDiv.innerHTML = '';

    const bubblesNeedingCites = [];

    history.forEach((msg) => {
      if (msg.type === 'human') {
        appendUserMessage(msg.content);
        if (msg.meta?.quick_uploaded_files?.length) {
          appendAttachedFilesToUserMessage(msg.meta.quick_uploaded_files);
        }
        return;
      }

      // AI message
      const bubble = createAgentMessageBubble();
      bubble.dataset.rawMarkdown = msg.content;
      bubble.dataset.streaming = 'false';

      const contentDiv = bubble.querySelector('.content');
      contentDiv.innerHTML = DOMPurify.sanitize(marked.parse(msg.content));

      // 1) Code blocks first
      renderCodeblocks(contentDiv);

      // 2) Citations: attach if present, otherwise mark for backfill
      if (Array.isArray(msg.meta?.citations) && msg.meta.citations.length) {
        hydrateCitationsForBubble(bubble, msg.meta.citations);
      } else {
        bubblesNeedingCites.push(bubble);
      }

      // 3) Math after citations are in the DOM
      renderMath(bubble);
    });

    // One backfill call for any AI bubbles that shipped without citations
    if (bubblesNeedingCites.length) {
      await backfillCitationsForBubbles(bubblesNeedingCites);
    }

    setTimeout(() => window.scrollTo(0, document.body.scrollHeight), 100);
  } catch (error) {
    console.error("Failed to fetch history:", error);
    showToast("Could not connect to server to load session.", true);
  }
}
    async function fetchChatSessions(agentName) {
        if (!loggedInUserToken || !loggedInDbUserId) {
            historyList.innerHTML = '';
            return;
        }
        try {
            const response = await fetch(`/sessions?agent_name=${agentName}&user_id=${loggedInDbUserId}`, {
                method: 'GET',
                headers: {
                    'X-API-Key': loggedInUserToken
                }
            });
            if (!response.ok) { throw new Error('Failed to fetch chat sessions.'); }
            const sessions = await response.json();
            historyList.innerHTML = '';

            if (sessions.length === 0) {
                 historyList.innerHTML = `<li class="no-history"><p>No chat history available.</p></li>`;
                 return;
            }
            sessions.forEach(session => {
                const li = document.createElement('li');
                li.dataset.threadId = session.thread_id;
                li.dataset.topicName = session.topic_name;
                const mainContent = document.createElement('div');
                mainContent.className = 'history-item-main';
                mainContent.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.5a1 1 0 0 0-.8.4l-1.9 2.533a1 1 0 0 1-1.6 0L5.3 12.4a1 1 0 0 0-.8-.4H2a2 2 0 0 1-2-2V2zm3.5 1a.5.5 0 0 0 0 1h9a.5.5 0 0 0 0-1h-9zm0 2.5a.5.5 0 0 0 0 1h9a.5.5 0 0 0 0-1h-9zm0 2.5a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1h-5z"/></svg>
                    <span class="history-item-text">${session.topic_name}</span>
                    <input type="text" class="rename-input" style="display: none;" />
                `;
                li.appendChild(mainContent);
                const actionsContainer = document.createElement('div');
                actionsContainer.className = 'history-item-actions';
                actionsContainer.innerHTML = `
                    <button class="action-btn rename-btn" title="Rename Chat">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"/></svg>
                    </button>
                    <button class="action-btn delete-btn" title="Delete Chat">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/><path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/></svg>
                    </button>
                `;
                li.appendChild(actionsContainer);
                if (session.thread_id === thread_id) { li.classList.add('active'); }
                mainContent.onclick = () => {
                    if (li.classList.contains('editing')) return;
                    document.querySelectorAll('#history-list li').forEach(item => item.classList.remove('active'));
                    li.classList.add('active');
                    thread_id = session.thread_id;
                    localStorage.setItem('ragnetic_thread_id', thread_id);
                    loadHistory(agent, thread_id, loggedInDbUserId);
                    openWebSocket();
                };
                addRenameFunctionality(li, session.thread_id);
                addDeleteFunctionality(li, session.thread_id);
                historyList.appendChild(li);
            });
        } catch (error) {
            console.error("Failed to fetch chat sessions:", error);
            historyList.innerHTML = `<li class="no-history"><p>No chat history available.</p></li>`;
        }
    }
    function addRenameFunctionality(liElement, currentThreadId) {
        const renameButton = liElement.querySelector('.rename-btn');
        const textSpan = liElement.querySelector('.history-item-text');
        const renameInput = liElement.querySelector('.rename-input');
        renameButton.onclick = (e) => {
            e.stopPropagation();
            liElement.classList.add('editing');
            renameInput.style.display = 'block';
            textSpan.style.display = 'none';
            renameInput.value = textSpan.textContent;
            renameInput.focus();
        };
        const finishEditing = async () => {
            const newName = renameInput.value.trim();
            const oldName = textSpan.textContent;
            if (newName && newName !== oldName) {
                if (!loggedInUserToken || !loggedInDbUserId) {
                    showToast("Please log in to rename chats.", true);
                    return;
                }
                try {
                    const response = await fetch(`/sessions/${currentThreadId}/rename?agent_name=${agent}&user_id=${loggedInDbUserId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-API-Key': loggedInUserToken
                        },
                        body: JSON.stringify({ new_name: newName })
                    });
                    if (!response.ok) throw new Error('Failed to rename session.');
                    textSpan.textContent = newName;
                    showToast('Chat renamed successfully!');
                } catch (error) {
                    console.error('Rename failed:', error);
                    showToast('Error: Could not rename chat.', true);
                }
            }
            liElement.classList.remove('editing');
            renameInput.style.display = 'none';
            textSpan.style.display = 'block';
        };
        renameInput.onblur = finishEditing;
        renameInput.onkeydown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                finishEditing();
            } else if (e.key === 'Escape') {
                liElement.classList.remove('editing');
                renameInput.style.display = 'none';
                textSpan.style.display = 'block';
            }
        };
    }
    function addDeleteFunctionality(liElement, currentThreadId) {
        const deleteButton = liElement.querySelector('.delete-btn');
        deleteButton.onclick = (e) => {
            e.stopPropagation();
            showConfirmationModal(() => {
                deleteChatSession(liElement, currentThreadId);
            }, "Are you sure you want to delete this chat?", "Delete");
        };
    }
    async function deleteChatSession(liElement, currentThreadId) {
        if (!loggedInUserToken || !loggedInDbUserId) {
            showToast("Please log in to delete chats.", true);
            return;
        }
        try {
            const response = await fetch(`/sessions/${currentThreadId}?agent_name=${agent}&user_id=${loggedInDbUserId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'X-API-Key': loggedInUserToken
                }
            });
            if (!response.ok) { throw new Error('Failed to delete session.'); }
            showToast('Chat deleted successfully!');
            liElement.remove();
            if (thread_id === currentThreadId) {
                startNewSession();
            }
        } catch(error) {
            console.error("Delete failed:", error);
            showToast('Error: Could not delete chat.', true);
        }
    }
    function showConfirmationModal(onConfirm, text = "Are you sure?", confirmText = "Start New") {
        if (confirmText === "Start New" && (messagesDiv.children.length === 0 || document.getElementById('empty-state'))) {
            onConfirm();
            return;
        }
        modalText.textContent = text;
        modalConfirmBtn.textContent = confirmText;
        modalConfirmBtn.className = confirmText === "Delete" ? 'modal-btn confirm error' : 'modal-btn confirm';
        confirmCallback = onConfirm;
        confirmationModal.style.display = 'flex';
    }
    function startNewSession(showConfirmation = true) {
        const doReset = () => {
            localStorage.removeItem('ragnetic_thread_id');
            thread_id = null;
            renderEmptyState();
            openWebSocket();
            fetchChatSessions(agent);
            window.quickUploads.clearAttachedFiles();
        };

        if (showConfirmation) {
            showConfirmationModal(doReset, "Start a new chat?", "Start New");
        } else {
            doReset();
        }
    }
    logoutBtn.addEventListener('click', () => {
        loggedInUserToken = null;
        loggedInDbUserId = null;
        localStorage.removeItem('ragnetic_user_token');
        localStorage.removeItem('ragnetic_db_user_id');
        localStorage.removeItem('ragnetic_thread_id');
        localStorage.removeItem('ragnetic_user_id');
        localStorage.removeItem('ragnetic_agent');

        thread_id = null;
        agent = null;
        showToast("Logged out successfully.");
        window.location.href = '/login';
        messagesDiv.innerHTML = '';
        historyList.innerHTML = '';
        if (socket && socket.readyState !== WebSocket.CLOSED) {
            socket.close(1000, "User logged out");
        }
        renderEmptyState();
        window.quickUploads.clearAttachedFiles();
    });
    document.addEventListener('DOMContentLoaded', async () => {
        // REMOVED: sources-panel logic
        if (loggedInUserToken && loggedInDbUserId) {
            setupChatEnvironment();
            try {
                const response = await fetch('/static/html/ingestion_modal.html');
                if (!response.ok) {
                    throw new Error(`Failed to load ingestion modal HTML from /static/html: ${response.statusText}`);
                }
                ingestionModal.innerHTML = await response.text();
                if (window.IngestionModal && typeof window.IngestionModal.init === 'function') {
                    window.IngestionModal.init();
                } else {
                    console.error("IngestionModal.init not found. Script might have failed or not exposed it globally.");
                    showToast("Ingestion modal script failed to load correctly. Please refresh.", true);
                }
            } catch (error) {
                console.error("Error loading ingestion modal:", error);
                showToast(`Error loading ingestion modal: ${error.message}`, true);
                openIngestionModalBtn.disabled = true;
            }
        } else {
            window.location.href = '/login';
        }
    });
    newChatButton.addEventListener('click', () => startNewSession());
    agentSelect.addEventListener('change', () => showConfirmationModal(() => {
        agent = agentSelect.value;
        localStorage.setItem('ragnetic_agent', agent);
        startNewSession(false);
        if (ingestionModal.style.display === 'flex' && window.IngestionModal && typeof window.IngestionModal.loadAgents === 'function') {
            window.IngestionModal.loadAgents(agent);
        }
    }, "Change agent and start a new chat?", "Change Agent"));
    modalCancelBtn.addEventListener('click', () => { confirmationModal.style.display = 'none'; confirmCallback = null; });
    modalConfirmBtn.addEventListener('click', () => { if (confirmCallback) confirmCallback(); confirmationModal.style.display = 'none'; confirmCallback = null; });
    inputField.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleFormSubmit();
        }
    });
    inputField.addEventListener('input', () => {
        inputField.style.height = 'auto';
        inputField.style.height = `${inputField.scrollHeight}px`;
    });
    openIngestionModalBtn.addEventListener('click', async () => {
        if (!loggedInUserToken || !loggedInDbUserId) {
            showToast("Please log in to ingest data.", true);
            window.location.href = '/login';
            return;
        }
        if (window.IngestionModal && typeof window.IngestionModal.loadAgents === 'function') {
            await window.IngestionModal.loadAgents(agentSelect.value);
            const ingestionSourceTypeSelectInModal = ingestionModal.querySelector('#ingestionSourceType');
            if (ingestionSourceTypeSelectInModal) {
                window.IngestionModal.renderIngestionSourceFields(ingestionSourceTypeSelectInModal.value);
            } else {
                console.warn("ingestionSourceTypeSelect not found on modal open, might be timing issue.");
            }
            if (window.IngestionModal && typeof window.IngestionModal.showIngestionFormPanel === 'function') {
                window.IngestionModal.showIngestionFormPanel();
            }
            ingestionModal.style.display = 'flex';
        } else {
             console.error("Ingestion modal logic not initialized or functions missing.");
             showToast("Ingestion modal not ready. Please refresh.", true);
        }
    });
    if (quickUploadBtn) {
        quickUploadBtn.addEventListener('click', () => {
            quickUploadFileInput.click();
        });
    }
    if (quickUploadFileInput) {
        quickUploadFileInput.addEventListener('change', (event) => {
            if (window.quickUploads && typeof window.quickUploads.handleFileSelection === 'function') {
                window.quickUploads.handleFileSelection(event.target.files);
            }
            event.target.value = '';
        });
    }
</script>
</body>
</html>