<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>RAGnetic Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=JetBrains+Mono&display=swap" rel="stylesheet" />

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <link rel="stylesheet" href="{{ url_for('static', path='css/style.css') }}">
</head>
<body>
    <div id="toast-notification"></div>
    <div id="confirmation-modal">
        <div class="modal-content"><p id="modal-text">Are you sure? Your current chat history will be cleared.</p><div class="modal-buttons"><button id="modal-cancel-btn" class="modal-btn cancel">Cancel</button><button id="modal-confirm-btn" class="modal-btn confirm">Start New</button></div></div>
    </div>

    <div id="chat-container">
        <header>
            <select id="agent-select" name="agent">
                {% for a in agents %}
                <option value="{{ a.name }}" {% if a.name == agent %}selected{% endif %}>{{ a.display_name }}</option>
                {% endfor %}
            </select>
            <button id="new-chat-btn" title="New Chat">New Chat</button>
        </header>

        <div id="messages"></div>

        <div id="input-form-container">
            <div id="typing-indicator" style="opacity: 0; display:none;"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
            <form id="input-form" onsubmit="handleFormSubmit(event)">
                <textarea name="query" id="query-input" placeholder="Ask RAGneticâ€¦" rows="1"></textarea>
                <button type="submit" id="send-stop-btn">
                    <span id="send-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" /></svg></span>
                    <span id="stop-icon" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M6 6h12v12H6V6z"></path></svg></span>
                </button>
            </form>
        </div>
    </div>

    <script>
        // NEW: Get the API key passed from the backend
        const GLOBAL_API_KEY = "{{ api_key }}"; // This will be rendered by Jinja2

        const agentSelect = document.getElementById('agent-select');
        const messagesDiv = document.getElementById('messages');
        const inputField = document.getElementById('query-input');
        const sendStopButton = document.getElementById('send-stop-btn');
        const sendIcon = document.getElementById('send-icon');
        const stopIcon = document.getElementById('stop-icon');
        const typingIndicator = document.getElementById('typing-indicator');
        const newChatButton = document.getElementById('new-chat-btn');
        const toastNotification = document.getElementById('toast-notification');
        const confirmationModal = document.getElementById('confirmation-modal');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        let agent, user_id, thread_id, socket;
        let isFirstMessage = true;
        let confirmCallback = null;
        let isGenerating = false;
        const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
        const svgs = {
            copy: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M7.5 3a.75.75 0 00-.75.75v13.5a.75.75 0 00.75.75h9a.75.75 0 00.75-.75V3.75A.75.75 0 0016.5 3h-9zM8.25 4.5h7.5v12h-7.5V4.5z" /><path d="M6 1.5a.75.75 0 00-.75.75V16.5a.75.75 0 00.75.75h.008a.75.75 0 00.75-.75V2.25A.75.75 0 006.008 1.5H6z" /></svg>`,
            copied: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path fill-rule="evenodd" d="M19.916 4.626a.75.75 0 01.208 1.04l-9 13.5a.75.75 0 01-1.154.114l-6-6a.75.75 0 011.06-1.06l5.353 5.353 8.493-12.739a.75.75 0 011.04-.208z" clip-rule="evenodd" /></svg>`
        };

        function renderMath(element) {
            if (window.MathJax) {
                window.MathJax.typesetPromise(element ? [element] : []).catch((err) => console.error('MathJax typesetting error:', err));
            }
        }

        function showToast(message, isError = true) {
            toastNotification.textContent = message;
            toastNotification.style.borderColor = isError ? "var(--error-color)" : "var(--success-color)";
            toastNotification.style.display = 'block';
            setTimeout(() => { toastNotification.style.display = 'none'; }, 4000);
        }

        function scrollToBottom() {
            const scrollThreshold = 100;
            const isScrolledNearBottom = messagesDiv.scrollHeight - messagesDiv.clientHeight <= messagesDiv.scrollTop + scrollThreshold;
            if (isScrolledNearBottom) {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        }

        function setGeneratingState(generating) {
            isGenerating = generating;
            sendIcon.style.display = generating ? 'none' : 'inline';
            stopIcon.style.display = generating ? 'inline' : 'none';
            inputField.disabled = generating;
            sendStopButton.classList.toggle('stop-active', generating);
            if (!generating) {
                typingIndicator.style.display = 'none';
                inputField.focus();
            }
        }

        function renderEmptyState() {
            messagesDiv.innerHTML = `<div id="empty-state"><h1>RAG<span>netic</span></h1><p>Your on-premise AI assistant. Select an agent and ask a question to begin.</p></div>`;
        }

        function openWebSocket(onOpenCallback) {
            if (socket && socket.readyState !== WebSocket.CLOSED) {
                socket.close(1000, "Starting new session");
            }
            // Construct the WebSocket URL with the API key
            let wsUrl = `${protocol}://${location.host}/ws`;
            // Only add API key if it's not empty (i.e., if keys are configured on the server)
            if (GLOBAL_API_KEY) {
                wsUrl += `?api_key=${GLOBAL_API_KEY}`;
            }

            socket = new WebSocket(wsUrl); // Use the constructed URL
            isFirstMessage = true;

            socket.onopen = () => {
                sendStopButton.disabled = false;
                if (onOpenCallback) {
                    onOpenCallback();
                }
            };
            socket.onerror = (event) => {
                console.error("WebSocket error:", event);
                showToast("Connection error. Check console for details.", true);
            };
            socket.onclose = (event) => {
                sendStopButton.disabled = true;
                if (isGenerating) setGeneratingState(false);
                if (event.code === 1008) {
                    showToast("Connection rejected: Invalid or missing API Key. Please run 'ragnetic set-server-key' if this is unexpected.", true);
                } else if (event.code === 1000 && event.reason === "Starting new session") {
                    // Do NOT show a toast for this normal event!
                    // Optionally log to console for debugging:
                    // console.log("WebSocket closed (new session):", event);
                } else {
                    showToast(`WebSocket disconnected: Code ${event.code}, Reason: ${event.reason}`, true);
                }
            };
                        socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.token) {
                    typingIndicator.style.display = 'none';
                    appendAgentToken(data.token);
                }
                if (data.done) {
                    setGeneratingState(false);
                    if (data.is_first_message) {
                        user_id = data.user_id;
                        thread_id = data.thread_id;
                        localStorage.setItem('ragnetic_user_id', user_id);
                        localStorage.setItem('ragnetic_thread_id', thread_id);
                        localStorage.setItem('ragnetic_agent', agent);
                        isFirstMessage = false;
                    }
                    const lastMessage = messagesDiv.lastElementChild;
                    if (lastMessage && lastMessage.classList.contains('agent')) {
                        lastMessage.dataset.streaming = 'false';
                        renderCodeblocks(lastMessage);
                        renderMath(lastMessage);
                    }
                }
            };
        }

        function handleFormSubmit(event) {
            if (event) event.preventDefault();
            if (isGenerating) {
                socket.send(JSON.stringify({ type: 'interrupt' }));
                setGeneratingState(false);
            } else {
                sendMessage();
            }
        }

        function sendMessage() {
            const query = inputField.value.trim();
            if (!query) return;

            const payload = { agent, user_id, thread_id, query };
            const message = { type: 'query', payload: payload };

            const doSend = () => {
                socket.send(JSON.stringify(message));
                const emptyState = document.getElementById('empty-state');
                if (emptyState) emptyState.remove();
                appendUserMessage(query);
                setGeneratingState(true);
                typingIndicator.style.display = 'flex';
                typingIndicator.style.opacity = '1';
                scrollToBottom();
                inputField.value = '';
                inputField.style.height = 'auto';
            };

            if (!socket || socket.readyState !== WebSocket.OPEN) {
                showToast("Connecting... Please try again shortly.", false);
                // Open a new connection and pass the sending action as a callback
                openWebSocket(doSend);
            } else {
                doSend();
            }
        }

        function appendUserMessage(text) {
            const msg = document.createElement('div');
            msg.className = 'message user';
            msg.textContent = text;
            messagesDiv.appendChild(msg);
            scrollToBottom();
        }

        function createAgentMessageBubble() {
            const bubble = document.createElement('div');
            bubble.className = 'message agent';
            const contentDiv = document.createElement('div');
            contentDiv.className = 'content';
            bubble.appendChild(contentDiv);
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.innerHTML = svgs.copy;
            copyBtn.onclick = (e) => {
                const rawMarkdown = e.currentTarget.closest('.message.agent').dataset.rawMarkdown;
                if (rawMarkdown) {
                    navigator.clipboard.writeText(rawMarkdown).then(() => {
                        e.currentTarget.innerHTML = svgs.copied;
                        setTimeout(() => { e.currentTarget.innerHTML = svgs.copy; }, 2000);
                    });
                }
            };
            bubble.appendChild(copyBtn);
            bubble.dataset.rawMarkdown = '';
            messagesDiv.appendChild(bubble);
            return bubble;
        }

        function renderCodeblocks(scopeElement) {
            scopeElement.querySelectorAll('pre > code').forEach((codeBlock) => {
                const pre = codeBlock.parentElement;
                if (pre.querySelector('.code-header')) return;
                const lang = codeBlock.className.split('-')[1] || 'text';
                const header = document.createElement('div');
                header.className = 'code-header';
                const langSpan = document.createElement('span');
                langSpan.textContent = lang;
                const copyBtn = document.createElement('button');
                copyBtn.className = 'code-copy-btn';
                copyBtn.textContent = 'Copy';
                copyBtn.onclick = () => {
                    navigator.clipboard.writeText(codeBlock.textContent).then(() => {
                        copyBtn.textContent = 'Copied!';
                        setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
                    });
                };
                header.appendChild(langSpan);
                header.appendChild(copyBtn);
                pre.insertBefore(header, codeBlock);
            });
        }

        function appendAgentToken(token) {
            let lastMessage = messagesDiv.lastElementChild;
            if (!lastMessage || !lastMessage.classList.contains('agent') || lastMessage.dataset.streaming === 'false') {
                typingIndicator.style.display = 'none';
                lastMessage = createAgentMessageBubble();
                lastMessage.dataset.streaming = 'true';
            }
            lastMessage.dataset.rawMarkdown += token;
            const contentDiv = lastMessage.querySelector('.content');
            if (contentDiv) {
                contentDiv.innerHTML = marked.parse(lastMessage.dataset.rawMarkdown);
                renderCodeblocks(contentDiv);
            }
            scrollToBottom();
        }

        async function loadHistory(agentName, threadId, userId) {
            try {
                // IMPORTANT: Pass the API key for history requests too
                const response = await fetch(`/history/${threadId}?agent_name=${agentName}&user_id=${userId}&api_key=${GLOBAL_API_KEY}`);
                if (!response.ok) {
                    showToast(`Could not load session (status: ${response.status}).`, true);
                    startNewSession(false);
                    return;
                }
                const history = await response.json();
                messagesDiv.innerHTML = '';
                history.forEach(msg => {
                    if (msg.type === 'human') appendUserMessage(msg.content);
                    else if (msg.type === 'ai') {
                        const agentMsgBubble = createAgentMessageBubble();
                        agentMsgBubble.dataset.rawMarkdown = msg.content;
                        const contentDiv = agentMsgBubble.querySelector('.content');
                        contentDiv.innerHTML = marked.parse(msg.content);
                        agentMsgBubble.dataset.streaming = 'false';
                        renderCodeblocks(contentDiv);
                        renderMath(contentDiv);
                    }
                });
                setTimeout(scrollToBottom, 100);
            } catch (error) {
                console.error("Failed to fetch history:", error);
                showToast("Could not connect to server to load session.", true);
            }
        }

        function showConfirmationModal(onConfirm) {
            if (messagesDiv.children.length === 0 || document.getElementById('empty-state')) {
                onConfirm();
                return;
            }
            confirmCallback = onConfirm;
            confirmationModal.style.display = 'flex';
        }

        function startNewSession(openConnection = true) {
            localStorage.removeItem('ragnetic_user_id');
            localStorage.removeItem('ragnetic_thread_id');
            localStorage.removeItem('ragnetic_agent');
            user_id = "";
            thread_id = "";
            renderEmptyState();
            if (openConnection) openWebSocket();
        }

        document.addEventListener('DOMContentLoaded', () => {
          const savedAgent    = localStorage.getItem('ragnetic_agent');
          const savedThreadId = localStorage.getItem('ragnetic_thread_id');
          const savedUserId   = localStorage.getItem('ragnetic_user_id');

          if (savedAgent) agentSelect.value = savedAgent;
          agent = agentSelect.value;

          // Only attempt to load history if an API key is present
          if (GLOBAL_API_KEY && savedAgent && savedThreadId && savedUserId) {
            // re-hydrate globals
            user_id   = savedUserId;
            thread_id = savedThreadId;
            loadHistory(agent, thread_id, user_id);
          } else {
            renderEmptyState();
          }

          openWebSocket(); // Always try to open WebSocket on load
        });

        newChatButton.addEventListener('click', () => showConfirmationModal(startNewSession));
        agentSelect.addEventListener('change', () => showConfirmationModal(() => {
            agent = agentSelect.value;
            startNewSession();
        }));
        modalCancelBtn.addEventListener('click', () => {
            confirmationModal.style.display = 'none';
            confirmCallback = null;
        });
        modalConfirmBtn.addEventListener('click', () => {
            if (confirmCallback) confirmCallback();
            confirmationModal.style.display = 'none';
            confirmCallback = null;
        });
        inputField.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleFormSubmit();
            }
        });
        inputField.addEventListener('input', () => {
            inputField.style.height = 'auto';
            inputField.style.height = `${inputField.scrollHeight}px`;
        });
    </script>
</body>
</html>