<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>RAGnetic Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=JetBrains+Mono&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="{{ url_for('static', path='css/style.css') }}">
</head>
<body>
    <div id="toast-notification"></div>

    <div id="confirmation-modal">
        <div class="modal-content">
            <p id="modal-text">Are you sure? Your current chat history will be cleared.</p>
            <div class="modal-buttons">
                <button id="modal-cancel-btn" class="modal-btn cancel">Cancel</button>
                <button id="modal-confirm-btn" class="modal-btn confirm">Start New</button>
            </div>
        </div>
    </div>

    <div id="chat-container">
        <header>
            <select id="agent-select" name="agent">
                {% for a in agents %}
                <option value="{{ a.name }}" {% if a.name == agent %}selected{% endif %}>{{ a.display_name }}</option>
                {% endfor %}
                </select>
            <button id="new-chat-btn" title="New Chat">New Chat</button>
        </header>

        <div id="messages">
            </div>

        <div id="input-form-container">
            <div id="typing-indicator" style="opacity: 0; display:none;">
                <div class="dot"></div><div class="dot"></div><div class="dot"></div>
            </div>
            <form id="input-form" onsubmit="sendMessage(event)">
                <textarea name="query" id="query-input" placeholder="Ask RAGneticâ€¦" rows="1"></textarea>
                <button type="submit" id="send-btn" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" /></svg>
                </button>
            </form>
        </div>
    </div>

    <script>
        // All const declarations
        const agentSelect = document.getElementById('agent-select');
        const messagesDiv = document.getElementById('messages');
        const inputField = document.getElementById('query-input');
        const sendButton = document.getElementById('send-btn');
        const typingIndicator = document.getElementById('typing-indicator');
        const newChatButton = document.getElementById('new-chat-btn');
        const toastNotification = document.getElementById('toast-notification');
        const confirmationModal = document.getElementById('confirmation-modal');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        // All let declarations
        let agent, user_id, thread_id, socket;
        let isFirstMessage = true;
        let confirmCallback = null;
        const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
        const svgs = {
            copy: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M7.5 3a.75.75 0 00-.75.75v13.5a.75.75 0 00.75.75h9a.75.75 0 00.75-.75V3.75A.75.75 0 0016.5 3h-9zM8.25 4.5h7.5v12h-7.5V4.5z" /><path d="M6 1.5a.75.75 0 00-.75.75V16.5a.75.75 0 00.75.75h.008a.75.75 0 00.75-.75V2.25A.75.75 0 006.008 1.5H6z" /></svg>`,
            copied: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path fill-rule="evenodd" d="M19.916 4.626a.75.75 0 01.208 1.04l-9 13.5a.75.75 0 01-1.154.114l-6-6a.75.75 0 011.06-1.06l5.353 5.353 8.493-12.739a.75.75 0 011.04-.208z" clip-rule="evenodd" /></svg>`
        };

        function showToast(message, isError = true) {
            toastNotification.textContent = message;
            toastNotification.style.borderColor = isError ? "var(--error-color)" : "var(--success-color)";
            toastNotification.style.display = 'block';
            setTimeout(() => { toastNotification.style.display = 'none'; }, 4000);
        }

        function scrollToBottom() {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function renderEmptyState() {
            messagesDiv.innerHTML = `
                <div id="empty-state">
                    <h1>RAG<span>netic</span></h1>
                    <p>Your on-premise AI assistant. Select an agent and ask a question to begin.</p>
                </div>
            `;
        }

        function openWebSocket() {
            if (socket && socket.readyState !== WebSocket.CLOSED) {
                socket.close(1000, "Starting new session");
            }
            socket = new WebSocket(`${protocol}://${location.host}/ws`);
            isFirstMessage = true;

            socket.onopen = () => sendButton.disabled = false;
            socket.onerror = () => showToast("Connection error.");
            socket.onclose = (event) => {
                sendButton.disabled = true;
                console.log("WebSocket closed.", event.reason);
            };
            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.token) {
                    typingIndicator.style.display = 'none';
                    appendAgentToken(data.token);
                }
                if (data.done) {
                    typingIndicator.style.display = 'none';
                    if (isFirstMessage) {
                        user_id = data.user_id;
                        thread_id = data.thread_id;
                        localStorage.setItem('ragnetic_user_id', user_id);
                        localStorage.setItem('ragnetic_thread_id', thread_id);
                        localStorage.setItem('ragnetic_agent', agent);
                        isFirstMessage = false;
                    }
                    const lastMessage = messagesDiv.lastElementChild;
                    if (lastMessage && lastMessage.classList.contains('agent')) {
                        lastMessage.dataset.streaming = 'false';
                        renderCodeblocks(lastMessage);
                    }
                }
            };
        }

        function sendMessage(event) {
            if (event) event.preventDefault();
            const query = inputField.value.trim();
            if (!query) return;

            if (!socket || socket.readyState !== WebSocket.OPEN) {
                showToast("Connecting... Please try again shortly.", false);
                openWebSocket();
                setTimeout(() => sendMessage(), 1000);
                return;
            }

            const emptyState = document.getElementById('empty-state');
            if(emptyState) emptyState.remove();

            appendUserMessage(query);
            typingIndicator.style.display = 'flex';
            typingIndicator.style.opacity = '1';
            scrollToBottom();

            const payload = isFirstMessage ? { agent, user_id, thread_id, query } : { query };
            socket.send(JSON.stringify(payload));

            inputField.value = '';
            inputField.style.height = 'auto';
            inputField.focus();
        }

        function appendUserMessage(text) {
            const msg = document.createElement('div');
            msg.className = 'message user';
            msg.textContent = text;
            messagesDiv.appendChild(msg);
            scrollToBottom();
        }

        function createAgentMessageBubble() {
            const bubble = document.createElement('div');
            bubble.className = 'message agent';
            const contentDiv = document.createElement('div');
            contentDiv.className = 'content';
            bubble.appendChild(contentDiv);

            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.innerHTML = svgs.copy;
            copyBtn.onclick = (e) => {
                const btn = e.currentTarget;
                const rawMarkdown = btn.closest('.message.agent').dataset.rawMarkdown;
                if (rawMarkdown) {
                    navigator.clipboard.writeText(rawMarkdown).then(() => {
                        btn.innerHTML = svgs.copied;
                        setTimeout(() => { btn.innerHTML = svgs.copy; }, 2000);
                    });
                }
            };
            bubble.appendChild(copyBtn);

            bubble.dataset.rawMarkdown = '';
            messagesDiv.appendChild(bubble);
            return bubble;
        }

        function renderCodeblocks(scopeElement) {
            scopeElement.querySelectorAll('pre > code').forEach((codeBlock) => {
                const pre = codeBlock.parentElement;
                if (pre.querySelector('.code-header')) return;

                const lang = codeBlock.className.split('-')[1] || 'text';
                const header = document.createElement('div');
                header.className = 'code-header';

                const langSpan = document.createElement('span');
                langSpan.textContent = lang;

                const copyBtn = document.createElement('button');
                copyBtn.className = 'code-copy-btn';
                copyBtn.textContent = 'Copy';
                copyBtn.onclick = () => {
                    navigator.clipboard.writeText(codeBlock.textContent).then(() => {
                        copyBtn.textContent = 'Copied!';
                        setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
                    });
                };

                header.appendChild(langSpan);
                header.appendChild(copyBtn);
                pre.insertBefore(header, codeBlock);
            });
        }

        function appendAgentToken(token) {
            let lastMessage = messagesDiv.lastElementChild;
            if (!lastMessage || !lastMessage.classList.contains('agent') || lastMessage.dataset.streaming === 'false') {
                typingIndicator.style.display = 'none';
                lastMessage = createAgentMessageBubble();
                lastMessage.dataset.streaming = 'true';
            }
            lastMessage.dataset.rawMarkdown += token;
            const contentDiv = lastMessage.querySelector('.content');
            if (contentDiv) {
                contentDiv.innerHTML = marked.parse(lastMessage.dataset.rawMarkdown);
                renderCodeblocks(contentDiv);
            }
            scrollToBottom();
        }

        async function loadHistory(agentName, threadId, userId) {
            try {
                const response = await fetch(`/history/${threadId}?agent_name=${agentName}&user_id=${userId}`);
                if (!response.ok) {
                    showToast(`Could not load session (status: ${response.status}).`, true);
                    startNewSession(false);
                    return;
                }
                const history = await response.json();
                messagesDiv.innerHTML = '';
                history.forEach(msg => {
                    if (msg.type === 'human') {
                        appendUserMessage(msg.content);
                    } else if (msg.type === 'ai') {
                        const agentMsgBubble = createAgentMessageBubble();
                        agentMsgBubble.dataset.rawMarkdown = msg.content;
                        const contentDiv = agentMsgBubble.querySelector('.content');
                        contentDiv.innerHTML = marked.parse(msg.content);
                        agentMsgBubble.dataset.streaming = 'false';
                        renderCodeblocks(contentDiv);
                    }
                });
                setTimeout(() => {
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                }, 100);
            } catch (error) {
                console.error("Failed to fetch history:", error);
                showToast("Could not connect to server to load session.", true);
            }
        }

        function showConfirmationModal(onConfirm) {
            if (messagesDiv.children.length === 0 || document.getElementById('empty-state')) {
                onConfirm();
                return;
            }
            confirmCallback = onConfirm;
            confirmationModal.style.display = 'flex';
        }

        function startNewSession(openConnection = true) {
            localStorage.removeItem('ragnetic_user_id');
            localStorage.removeItem('ragnetic_thread_id');
            localStorage.removeItem('ragnetic_agent');
            user_id = "";
            thread_id = "";
            renderEmptyState();
            if (openConnection) {
                openWebSocket();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const savedAgent = localStorage.getItem('ragnetic_agent');
            const savedThreadId = localStorage.getItem('ragnetic_thread_id');
            const savedUserId = localStorage.getItem('ragnetic_user_id');

            if (savedAgent) agentSelect.value = savedAgent;
            agent = agentSelect.value;

            if (savedAgent && savedThreadId && savedUserId) {
                loadHistory(savedAgent, savedThreadId, savedUserId);
            } else {
                renderEmptyState();
            }

            openWebSocket();
        });

        newChatButton.addEventListener('click', () => {
            showConfirmationModal(startNewSession);
        });

        agentSelect.addEventListener('change', () => {
            showConfirmationModal(() => {
                agent = agentSelect.value;
                startNewSession();
            });
        });

        modalCancelBtn.addEventListener('click', () => {
            confirmationModal.style.display = 'none';
            confirmCallback = null;
        });

        modalConfirmBtn.addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback();
            }
            confirmationModal.style.display = 'none';
            confirmCallback = null;
        });

        inputField.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        inputField.addEventListener('input', () => {
            inputField.style.height = 'auto';
            inputField.style.height = `${inputField.scrollHeight}px`;
        });
    </script>
</body>
</html>