<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>RAGnetic Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=JetBrains+Mono&display=swap" rel="stylesheet" />
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', path='css/style.css') }}">
</head>
<body>
    <div id="toast-notification"></div>
    <div id="confirmation-modal">
        <div class="modal-content">
            <p id="modal-text">Are you sure?</p>
            <div class="modal-buttons">
                <button id="modal-cancel-btn" class="modal-btn cancel">Cancel</button>
                <button id="modal-confirm-btn" class="modal-btn confirm">Confirm</button>
            </div>
        </div>
    </div>

    <div id="ingestion-modal" class="modal">
        <div class="modal-content large-modal">
            <span class="close-button" id="close-ingestion-modal">&times;</span>
            <h2>Document & Data Ingestion</h2>
            <form id="ingestion-form">
                <div class="form-group">
                    <label for="ingestionAgentName">Select Agent (Knowledge Base):</label>
                    <select id="ingestionAgentName" name="agentName" required>
                        <option value="">Loading agents...</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="ingestionSourceType">Source Type:</label>
                    <select id="ingestionSourceType" name="sourceType" required>
                        <option value="local_upload">Local File Upload (via browser)</option>
                        <option value="local">Local File Path (on server)</option>
                        <option value="url">Web URL</option>
                        <option value="db">Database (SQL)</option>
                        <option value="code_repository">Code Repository (Git)</option>
                        <option value="gdoc">Google Drive</option>
                        <option value="api">REST API</option>
                        <option value="web_crawler">Web Crawler</option>
                        </select>
                </div>

                <div id="ingestion-source-fields">
                    <div class="form-group file-upload-group">
                        <label for="fileInput">Choose File(s) from your computer:</label>
                        <input type="file" id="fileInput" name="fileInput" multiple>
                        <p class="info">Select one or more files to upload directly from your local machine. Supported types include PDF, DOCX, CSV, TXT, Jupyter Notebooks, Parquet files, and IaC files (YAML/Terraform).</p>
                    </div>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="reproducibleIds" name="reproducibleIds" checked>
                    <label for="reproducibleIds">Use Reproducible IDs (Consistent chunk hashing)</label>
                </div>
                 <div class="checkbox-group">
                    <input type="checkbox" id="parallelIngestion" name="parallelIngestion" checked>
                    <label for="parallelIngestion">Enable Parallel Ingestion (for directories, etc.)</label>
                </div>
                 <div class="form-group" id="numWorkersGroup" style="display: none;">
                    <label for="numIngestionWorkers">Number of Parallel Workers (defaults to CPU count):</label>
                    <input type="number" id="numIngestionWorkers" name="numIngestionWorkers" min="1">
                </div>


                <button type="submit" id="startIngestionBtn">Start Ingestion</button>
            </form>

            <div id="ingestion-status-messages">
                <p class="info-msg">Real-time ingestion progress and logs will appear here:</p>
            </div>

            <div id="ingestionProgressBarContainer">
                <div id="ingestionProgressBar"></div>
            </div>
        </div>
    </div>
    <aside id="chat-history-sidebar">
        <div class="sidebar-top">
            <button id="new-chat-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                <span>New Chat</span>
            </button>
            <select id="agent-select" name="agent">
                {% for a in agents %}
                <option value="{{ a.name }}" {% if a.name == agent %}selected{% endif %}>{{ a.display_name }}</option>
                {% endfor %}
            </select>
            <button id="open-ingestion-modal-btn">
                 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-database"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M3 5V19A9 3 0 0 0 21 19V5"/><path d="M3 12A9 3 0 0 0 21 12"/><path d="M3 19A9 3 0 0 0 21 19"/></svg>
                <span>Ingest Data</span>
            </button>
        </div>
        <h3 class="history-heading">Recent</h3>
        <ul id="history-list"></ul>
        <button id="logout-btn" style="width: 90%; margin: 10px auto; display: block; padding: 10px 15px; border: none; border-radius: 5px; background-color: #f44336; color: white; cursor: pointer; font-size: 1em;">Logout</button>
    </aside>
    <div id="chat-container">
        <div id="messages"></div>
        <div id="input-form-container">
            <div id="typing-indicator" style="opacity: 0; display:none;">
                <div class="pulsing-dot"></div>
                <span>RAGnetic is thinking...</span>
            </div>
            <form id="input-form" onsubmit="handleFormSubmit(event)">
                <textarea name="query" id="query-input" placeholder="Ask RAGneticâ€¦" rows="1"></textarea>
                <button type="submit" id="send-stop-btn">
                    <span id="send-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" /></svg></span>
                    <span id="stop-icon" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M6 6h12v12H6V6z"></path></svg></span>
                </button>
            </form>
            <p class="disclaimer-text">RAGnetic can make mistakes. Double check your source.</p>
        </div>
    </div>
    <script>
        const API_BASE_URL = window.location.origin + '/api/v1'; // Moved to top for global access
        const WS_URL = 'ws://' + window.location.host + '/ws'; // Moved to top for global access

        const agentSelect = document.getElementById('agent-select');
        const messagesDiv = document.getElementById('messages');
        const inputField = document.getElementById('query-input');
        const sendStopButton = document.getElementById('send-stop-btn');
        const sendIcon = document.getElementById('send-icon');
        const stopIcon = document.getElementById('stop-icon');
        const typingIndicator = document.getElementById('typing-indicator');
        const newChatButton = document.getElementById('new-chat-btn');
        const toastNotification = document.getElementById('toast-notification');
        const confirmationModal = document.getElementById('confirmation-modal');
        const modalText = document.getElementById('modal-text');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        const historySidebar = document.getElementById('chat-history-sidebar');
        const chatContainer = document.getElementById('chat-container');

        const historyList = document.getElementById('history-list');

        const logoutBtn = document.getElementById('logout-btn');

        // NEW: Ingestion Modal elements
        const ingestionModal = document.getElementById('ingestion-modal');
        const openIngestionModalBtn = document.getElementById('open-ingestion-modal-btn');
        const closeIngestionModalBtn = document.getElementById('close-ingestion-modal');
        const ingestionForm = document.getElementById('ingestion-form');
        const ingestionAgentNameSelect = document.getElementById('ingestionAgentName');
        const ingestionSourceTypeSelect = document.getElementById('ingestionSourceType');
        const ingestionSourceFieldsDiv = document.getElementById('ingestion-source-fields');
        const ingestionStatusMessagesDiv = document.getElementById('ingestion-status-messages');
        const ingestionProgressBar = document.getElementById('ingestionProgressBar');
        const startIngestionBtn = document.getElementById('startIngestionBtn');
        const parallelIngestionCheckbox = document.getElementById('parallelIngestion');
        const numWorkersGroup = document.getElementById('numWorkersGroup');
        const numIngestionWorkersInput = document.getElementById('numIngestionWorkers');

        let agent, thread_id, socket;
        let confirmCallback = null;
        let isGenerating = false;
        const protocol = location.protocol === 'https:' ? 'wss' : 'ws';

        let loggedInUserToken = localStorage.getItem('ragnetic_user_token');
        let loggedInDbUserId = localStorage.getItem('ragnetic_db_user_id');

        const svgs = {
            copy: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M7.5 3a.75.75 0 00-.75.75v13.5a.75.75 0 00.75.75h9a.75.75 0 00.75-.75V3.75A.75.75 0 0016.5 3h-9zM8.25 4.5h7.5v12h-7.5V4.5z" /><path d="M6 1.5a.75.75 0 00-.75.75V16.5a.75.75 0 00.75.75h.008a.75.75 0 00.75-.75V2.25A.75.75 0 006.008 1.5H6z" /></svg>`,
            copied: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path fill-rule="evenodd" d="M19.916 4.626a.75.75 0 01.208 1.04l-9 13.5a.75.75 0 01-1.154.114l-6-6a.75.75 0 011.06-1.06l5.353 5.353 8.493-12.739a.75.75 0 011.04-.208z" clip-rule="evenodd" /></svg>`,
            copyCode: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg>`,
            copiedCode: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 0 1 0-1.06.733.733 0 011.047 0l3.052 3.093 5.4-6.425a.247.247 0 01.02-.022z"/></svg>`
        };
        function renderMath(element) { if (window.MathJax) { window.MathJax.typesetPromise(element ? [element] : []).catch((err) => console.error('MathJax typesetting error:', err)); } }
        function showToast(message, isError = false) { toastNotification.textContent = message; toastNotification.className = isError ? 'error' : 'success'; toastNotification.style.display = 'block'; setTimeout(() => { toastNotification.style.display = 'none'; }, 4000); }
        function scrollToBottom() { window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' }); }
        function setGeneratingState(generating) { isGenerating = generating; sendIcon.style.display = generating ? 'none' : 'inline'; stopIcon.style.display = generating ? 'inline' : 'none'; inputField.disabled = generating; sendStopButton.classList.toggle('stop-active', generating); if (!generating) { typingIndicator.style.display = 'none'; inputField.focus(); } }
        function renderEmptyState() { messagesDiv.innerHTML = `<div id="empty-state"><h1>RAG<span>netic</span></h1><p>Your on-premise AI assistant. Select an agent and ask a question to begin.</p></div>`; }

        function setupChatEnvironment() {
            const savedAgent = localStorage.getItem('ragnetic_agent');
            if (savedAgent) {
                agentSelect.value = savedAgent;
            }
            agent = agentSelect.value;
            thread_id = localStorage.getItem('ragnetic_thread_id');

            if (thread_id) {
                loadHistory(agent, thread_id, loggedInDbUserId);
            } else {
                renderEmptyState();
            }
            fetchChatSessions(agent);
            openWebSocket();
        }

        function openWebSocket(onOpenCallback) {
            if (socket && socket.readyState !== WebSocket.CLOSED) { socket.close(1000, "Starting new session"); }
            let wsUrl = `${protocol}://${location.host}/ws`;
            if (loggedInUserToken) {
                wsUrl += `?api_key=${loggedInUserToken}`;
            }
            socket = new WebSocket(wsUrl);
            socket.onopen = () => { sendStopButton.disabled = false; if (onOpenCallback) { onOpenCallback(); } };
            socket.onerror = (event) => { console.error("WebSocket error:", event); showToast("Connection error. Check console for details.", true); };
            socket.onclose = (event) => {
                sendStopButton.disabled = true;
                if (isGenerating) setGeneratingState(false);
                if (event.code === 1008) { showToast("Connection rejected: Invalid or missing API Key.", true); }
                else if (event.code !== 1000) { showToast(`WebSocket disconnected: Code ${event.code}`, true); }
                else {
                    // Normal closure (1000) implies a logout or intentional refresh
                    // If not logged in, redirect to login page
                    if (!loggedInUserToken || !loggedInDbUserId) {
                        window.location.href = '/login';
                    }
                }
            };
            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.token) { typingIndicator.style.display = 'none'; appendAgentToken(data.token); }
                if (data.done) {
                    setGeneratingState(false);
                    if (data.user_id && data.user_id !== loggedInDbUserId) {
                        loggedInDbUserId = data.user_id;
                        localStorage.setItem('ragnetic_db_user_id', loggedInDbUserId);
                    }
                    thread_id = data.thread_id;
                     setTimeout(() => {
                        localStorage.setItem('ragnetic_thread_id', thread_id);
                        localStorage.setItem('ragnetic_agent', agent);
                    }, 10);
                    fetchChatSessions(agent);
                    const lastMessage = messagesDiv.lastElementChild;
                    if (lastMessage && lastMessage.classList.contains('agent')) { lastMessage.dataset.streaming = 'false'; renderCodeblocks(lastMessage); renderMath(lastMessage); }

                }
            };
        }
        function handleFormSubmit(event) { if (event) event.preventDefault(); if (isGenerating) { socket.send(JSON.stringify({ type: 'interrupt' })); setGeneratingState(false); } else { sendMessage(); } }
        function sendMessage() {
            if (!loggedInUserToken || !loggedInDbUserId) {
                showToast("Please log in to chat.", true);
                return;
            }
            const query = inputField.value.trim();
            if (!query) return;

            const payload = { agent, user_id: parseInt(loggedInDbUserId), thread_id, query };
            const message = { type: 'query', payload: payload };
            const doSend = () => {
                socket.send(JSON.stringify(message));
                const emptyState = document.getElementById('empty-state');
                if (emptyState) emptyState.remove();
                appendUserMessage(query);
                setGeneratingState(true);
                typingIndicator.style.opacity = '1';
                typingIndicator.style.display = 'flex';
                scrollToBottom();
                inputField.value = '';
                inputField.style.height = 'auto';
            };
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                showToast("Connecting... Please try again shortly.");
                openWebSocket(doSend);
            } else {
                doSend();
            }
        }
        function appendUserMessage(text) { const msg = document.createElement('div'); msg.className = 'message user'; msg.textContent = text; messagesDiv.appendChild(msg); scrollToBottom(); }
        function createAgentMessageBubble() { const bubble = document.createElement('div'); bubble.className = 'message agent'; const contentDiv = document.createElement('div'); contentDiv.className = 'content'; bubble.appendChild(contentDiv); const copyBtn = document.createElement('button'); copyBtn.className = 'copy-btn'; copyBtn.innerHTML = svgs.copy; copyBtn.onclick = (e) => { const rawMarkdown = e.currentTarget.closest('.message.agent').dataset.rawMarkdown; if (rawMarkdown) { navigator.clipboard.writeText(rawMarkdown).then(() => { e.currentTarget.innerHTML = svgs.copied; setTimeout(() => { e.currentTarget.innerHTML = svgs.copy; }, 2000); }); } }; bubble.appendChild(copyBtn); bubble.dataset.rawMarkdown = ''; messagesDiv.appendChild(bubble); return bubble; }
        function renderCodeblocks(scopeElement) {
            scopeElement.querySelectorAll('pre > code').forEach((codeBlock) => {
                const pre = codeBlock.parentElement;
                if (pre.querySelector('.code-header')) return;
                const lang = codeBlock.className.split('-')[1] || 'text';
                const header = document.createElement('div');
                header.className = 'code-header';
                const langSpan = document.createElement('span');
                langSpan.textContent = lang;
                const copyBtn = document.createElement('button');
                copyBtn.className = 'code-copy-btn';
                copyBtn.innerHTML = svgs.copyCode;
                copyBtn.onclick = () => {
                    navigator.clipboard.writeText(codeBlock.textContent).then(() => {
                        copyBtn.innerHTML = svgs.copiedCode;
                        setTimeout(() => {
                            copyBtn.innerHTML = svgs.copyCode;
                        }, 2000);
                    });
                };
                header.appendChild(langSpan);
                header.appendChild(copyBtn);
                pre.insertBefore(header, codeBlock);
            });
        }
        function appendAgentToken(token) { let lastMessage = messagesDiv.lastElementChild; if (!lastMessage || !lastMessage.classList.contains('agent') || lastMessage.dataset.streaming === 'false') { typingIndicator.style.display = 'none'; lastMessage = createAgentMessageBubble(); lastMessage.dataset.streaming = 'true'; } lastMessage.dataset.rawMarkdown += token; const contentDiv = lastMessage.querySelector('.content'); if (contentDiv) { contentDiv.innerHTML = marked.parse(lastMessage.dataset.rawMarkdown); renderCodeblocks(contentDiv); } scrollToBottom(); }

        async function loadHistory(agentName, threadId, userId) {
            if (!loggedInUserToken || !loggedInDbUserId) {
                showToast("Cannot load history: Not logged in.", true);
                return;
            }
            try {
                const response = await fetch(`/history/${threadId}?agent_name=${agentName}&user_id=${loggedInDbUserId}`, {
                    method: 'GET',
                    headers: {
                        'X-API-Key': loggedInUserToken
                    }
                });
                if (!response.ok) {
                    if (response.status === 404) {
                        console.warn(`History for thread ${threadId} not found or unauthorized.`);
                        startNewSession(false);
                        return;
                    }
                    showToast(`Could not load session (status: ${response.status}).`, true);
                    return;
                }
                const history = await response.json();
                messagesDiv.innerHTML = '';
                history.forEach(msg => { if (msg.type === 'human') appendUserMessage(msg.content); else if (msg.type === 'ai') { const agentMsgBubble = createAgentMessageBubble(); agentMsgBubble.dataset.rawMarkdown = msg.content; const contentDiv = agentMsgBubble.querySelector('.content'); contentDiv.innerHTML = marked.parse(msg.content); agentMsgBubble.dataset.streaming = 'false'; renderCodeblocks(contentDiv); renderMath(contentDiv); } });
                setTimeout(() => window.scrollTo(0, document.body.scrollHeight), 100);
            }
            catch (error) {
                console.error("Failed to fetch history:", error);
                showToast("Could not connect to server to load session.", true);
            }
        }

        async function fetchChatSessions(agentName) {
            if (!loggedInUserToken || !loggedInDbUserId) {
                historyList.innerHTML = '';
                return;
            }
            try {
                const response = await fetch(`/sessions?agent_name=${agentName}&user_id=${loggedInDbUserId}`, {
                    method: 'GET',
                    headers: {
                        'X-API-Key': loggedInUserToken
                    }
                });
                if (!response.ok) { throw new Error('Failed to fetch chat sessions.'); }
                const sessions = await response.json();
                historyList.innerHTML = '';
                if (sessions.length === 0) {
                     historyList.innerHTML = `<li class="no-history"><p>No chat history available.</p></li>`;
                     return;
                }
                sessions.forEach(session => {
                    const li = document.createElement('li');
                    li.dataset.threadId = session.thread_id;
                    li.dataset.topicName = session.topic_name;
                    const mainContent = document.createElement('div');
                    mainContent.className = 'history-item-main';
                    mainContent.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.5a1 1 0 0 0-.8.4l-1.9 2.533a1 1 0 0 1-1.6 0L5.3 12.4a1 1 0 0 0-.8-.4H2a2 2 0 0 1-2-2V2zm3.5 1a.5.5 0 0 0 0 1h9a.5.5 0 0 0 0-1h-9zm0 2.5a.5.5 0 0 0 0 1h9a.5.5 0 0 0 0-1h-9zm0 2.5a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1h-5z"/></svg>
                        <span class="history-item-text">${session.topic_name}</span>
                        <input type="text" class="rename-input" style="display: none;" />
                    `;
                    li.appendChild(mainContent);
                    const actionsContainer = document.createElement('div');
                    actionsContainer.className = 'history-item-actions';
                    actionsContainer.innerHTML = `
                        <button class="action-btn rename-btn" title="Rename Chat">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"/></svg>
                        </button>
                        <button class="action-btn delete-btn" title="Delete Chat">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/><path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/></svg>
                        </button>
                    `;
                    li.appendChild(actionsContainer);
                    if (session.thread_id === thread_id) { li.classList.add('active'); }
                    mainContent.onclick = () => {
                        if (li.classList.contains('editing')) return;
                        document.querySelectorAll('#history-list li').forEach(item => item.classList.remove('active'));
                        li.classList.add('active');
                        thread_id = session.thread_id;
                        localStorage.setItem('ragnetic_thread_id', thread_id);
                        loadHistory(agent, thread_id, loggedInDbUserId);
                        openWebSocket();
                    };
                    addRenameFunctionality(li, session.thread_id);
                    addDeleteFunctionality(li, session.thread_id);
                    historyList.appendChild(li);
                });
            } catch (error) {
                console.error("Failed to fetch chat sessions:", error);
                historyList.innerHTML = `<li class="no-history"><p>No chat history available.</p></li>`;
            }
        }

        function addRenameFunctionality(liElement, currentThreadId) {
            const renameButton = liElement.querySelector('.rename-btn');
            const textSpan = liElement.querySelector('.history-item-text');
            const renameInput = liElement.querySelector('.rename-input');
            renameButton.onclick = (e) => {
                e.stopPropagation();
                liElement.classList.add('editing');
                renameInput.style.display = 'block';
                textSpan.style.display = 'none';
                renameInput.value = textSpan.textContent;
                renameInput.focus();
            };
            const finishEditing = async () => {
                const newName = renameInput.value.trim();
                const oldName = textSpan.textContent;
                if (newName && newName !== oldName) {
                    if (!loggedInUserToken || !loggedInDbUserId) {
                        showToast("Please log in to rename chats.", true);
                        return;
                    }
                    try {
                        const response = await fetch(`/sessions/${currentThreadId}/rename?agent_name=${agent}&user_id=${loggedInDbUserId}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-API-Key': loggedInUserToken
                            },
                            body: JSON.stringify({ new_name: newName })
                        });
                        if (!response.ok) throw new Error('Failed to rename session.');
                        textSpan.textContent = newName;
                        showToast('Chat renamed successfully!');
                    } catch (error) {
                        console.error('Rename failed:', error);
                        showToast('Error: Could not rename chat.', true);
                    }
                }
                liElement.classList.remove('editing');
                renameInput.style.display = 'none';
                textSpan.style.display = 'block';
            };
            renameInput.onblur = finishEditing;
            renameInput.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEditing();
                } else if (e.key === 'Escape') {
                    liElement.classList.remove('editing');
                    renameInput.style.display = 'none';
                    textSpan.style.display = 'block';
                }
            };
        }

        function addDeleteFunctionality(liElement, currentThreadId) {
            const deleteButton = liElement.querySelector('.delete-btn');
            deleteButton.onclick = (e) => {
                e.stopPropagation();
                showConfirmationModal(() => {
                    deleteChatSession(liElement, currentThreadId);
                }, "Are you sure you want to delete this chat?", "Delete");
            };
        }
        async function deleteChatSession(liElement, currentThreadId) {
            if (!loggedInUserToken || !loggedInDbUserId) {
                showToast("Please log in to delete chats.", true);
                return;
            }
            try {
                const response = await fetch(`/sessions/${currentThreadId}?agent_name=${agent}&user_id=${loggedInDbUserId}`, {
                    method: 'DELETE',
                    headers: {
                        'X-API-Key': loggedInUserToken
                    }
                });
                if (!response.ok) { throw new Error('Failed to delete session.'); }
                showToast('Chat deleted successfully!');
                liElement.remove();
                if (thread_id === currentThreadId) {
                    startNewSession();
                }
            } catch(error) {
                console.error("Delete failed:", error);
                showToast('Error: Could not delete chat.', true);
            }
        }
        function showConfirmationModal(onConfirm, text = "Are you sure?", confirmText = "Start New") {
            if (confirmText === "Start New" && (messagesDiv.children.length === 0 || document.getElementById('empty-state'))) {
                onConfirm();
                return;
            }
            modalText.textContent = text;
            modalConfirmBtn.textContent = confirmText;
            modalConfirmBtn.className = confirmText === "Delete" ? 'modal-btn confirm error' : 'modal-btn confirm';
            confirmCallback = onConfirm;
            confirmationModal.style.display = 'flex';
        }
        function startNewSession() {
            localStorage.removeItem('ragnetic_thread_id');
            thread_id = null;
            renderEmptyState();
            openWebSocket();
            fetchChatSessions(agent);
        }

        // Logout handler
        logoutBtn.addEventListener('click', () => {
            loggedInUserToken = null;
            loggedInDbUserId = null;
            localStorage.removeItem('ragnetic_user_token');
            localStorage.removeItem('ragnetic_db_user_id');
            localStorage.removeItem('ragnetic_thread_id');
            localStorage.removeItem('ragnetic_user_id');
            localStorage.removeItem('ragnetic_agent');
            thread_id = null;
            agent = null;
            showToast("Logged out successfully.");
            // Redirect to login page after logout
            window.location.href = '/login';
            messagesDiv.innerHTML = '';
            historyList.innerHTML = '';
            if (socket && socket.readyState !== WebSocket.CLOSED) {
                socket.close(1000, "User logged out");
            }
            renderEmptyState();
        });


        // Consolidated DOMContentLoaded listener
        document.addEventListener('DOMContentLoaded', () => {
            // Check if user is already logged in (has a token and DB ID)
            if (loggedInUserToken && loggedInDbUserId) {
                setupChatEnvironment();
            } else {
                window.location.href = '/login'; // Redirect to login if not authenticated
            }
        });

        newChatButton.addEventListener('click', () => showConfirmationModal(startNewSession, "Start a new chat?", "Start New"));
        agentSelect.addEventListener('change', () => showConfirmationModal(() => { agent = agentSelect.value; localStorage.setItem('ragnetic_agent', agent); startNewSession(); }, "Change agent and start a new chat?", "Change Agent"));
        modalCancelBtn.addEventListener('click', () => { confirmationModal.style.display = 'none'; confirmCallback = null; });
        modalConfirmBtn.addEventListener('click', () => { if (confirmCallback) confirmCallback(); confirmationModal.style.display = 'none'; confirmCallback = null; });
        inputField.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleFormSubmit(); } });
        inputField.addEventListener('input', () => { inputField.style.height = 'auto'; inputField.style.height = `${inputField.scrollHeight}px`; });


        // === NEW INGESTION MODAL LOGIC ===
        openIngestionModalBtn.addEventListener('click', async () => {
            if (!loggedInUserToken || !loggedInDbUserId) {
                showToast("Please log in to ingest data.", true);
                window.location.href = '/login';
                return;
            }
            await loadIngestionAgents(agentSelect.value); // Pass currently selected agent
            renderIngestionSourceFields(ingestionSourceTypeSelect.value); // Render fields for default type
            ingestionModal.style.display = 'flex'; // Show modal
        });

        closeIngestionModalBtn.addEventListener('click', () => {
            ingestionModal.style.display = 'none'; // Hide modal
            ingestionForm.reset(); // Reset the form fields
            ingestionStatusMessagesDiv.innerHTML = '<p class="info-msg">Real-time ingestion progress and logs will appear here:</p>'; // Clear messages
            ingestionProgressBar.style.width = '0%';
            ingestionProgressBar.textContent = '';
            startIngestionBtn.disabled = false;
            startIngestionBtn.textContent = "Start Ingestion";
        });

        ingestionSourceTypeSelect.addEventListener('change', (event) => {
            renderIngestionSourceFields(event.target.value);
        });

        parallelIngestionCheckbox.addEventListener('change', (event) => {
            if (['local', 'code_repository', 'directory', 'web_crawler', 'local_upload'].includes(ingestionSourceTypeSelect.value)) {
                numWorkersGroup.style.display = event.target.checked ? 'block' : 'none';
            }
        });

        async function loadIngestionAgents(currentChatAgentName) { // Accept currentChatAgentName
            if (!loggedInUserToken) { // Explicit check before fetch
                addIngestionStatusMessage('Authentication token missing. Cannot load agents.', 'error');
                return; // Stop execution
            }
            try {
                const response = await fetch(`${API_BASE_URL}/agents`, {
                    headers: { 'X-API-Key': loggedInUserToken }
                });
                if (response.ok) {
                    const agents = await response.json();
                    ingestionAgentNameSelect.innerHTML = '<option value="">-- Select an Agent --</option>';
                    agents.forEach(agentItem => {
                        const option = document.createElement('option');
                        option.value = agentItem.name;
                        option.textContent = agentItem.display_name || agentItem.name;
                        ingestionAgentNameSelect.appendChild(option);
                    });
                    if (agents.length > 0) {
                        // Pre-select the current chat agent if available, otherwise first agent
                        ingestionAgentNameSelect.value = currentChatAgentName || agents[0].name;
                    }
                } else {
                    addIngestionStatusMessage(`Error loading agents: ${response.status} - ${response.statusText}`, 'error');
                    console.error('Failed to load agents for ingestion modal:', response.status, response.statusText);
                }
            } catch (error) {
                addIngestionStatusMessage('Network error while loading agents for ingestion. Check server connection.', 'error');
                console.error('Network error during ingestion agent load:', error);
            }
        }

        // Helper for ingestion modal status messages
        function addIngestionStatusMessage(message, type = 'info') {
            const p = document.createElement('p');
            p.className = `status-message ${type}-msg`;
            p.textContent = message;
            ingestionStatusMessagesDiv.appendChild(p);
            ingestionStatusMessagesDiv.scrollTop = ingestionStatusMessagesDiv.scrollHeight;
        }

        function renderIngestionSourceFields(sourceType) {
            ingestionSourceFieldsDiv.innerHTML = '';
            let fieldsHtml = '';
            numWorkersGroup.style.display = 'none'; // Hide by default

            switch (sourceType) {
                case 'local_upload':
                    fieldsHtml = `
                        <div class="form-group file-upload-group">
                            <label for="fileInput">Choose File(s) from your computer:</label>
                            <input type="file" id="fileInput" name="fileInput" multiple required>
                            <p class="info">Select one or more files to upload directly from your local machine. Supported types include PDF, DOCX, CSV, TXT, Jupyter Notebooks, Parquet files, and IaC files (YAML/Terraform).</p>
                        </div>
                    `;
                    numWorkersGroup.style.display = parallelIngestionCheckbox.checked ? 'block' : 'none';
                    break;
                case 'local':
                    fieldsHtml = `
                        <div class="form-group file-upload-group">
                            <label for="filePath">File Path (relative to project root):</label>
                            <input type="text" id="filePath" name="filePath" placeholder="e.g., data/my_documents/doc.txt" required>
                            <p class="info">Ensure this path is within your RAGnetic project's configured allowed data directories.</p>
                        </div>
                    `;
                    numWorkersGroup.style.display = parallelIngestionCheckbox.checked ? 'block' : 'none';
                    break;
                case 'url':
                case 'web_crawler':
                    fieldsHtml = `
                        <div class="form-group">
                            <label for="urlPath">URL:</label>
                            <input type="url" id="urlPath" name="urlPath" placeholder="e.g., https://example.com/docs" required>
                        </div>
                    `;
                    if (sourceType === 'web_crawler') {
                        fieldsHtml += `
                            <div class="form-group">
                                <label for="maxDepth">Max Crawl Depth:</label>
                                <input type="number" id="maxDepth" name="maxDepth" value="2" min="1">
                            </div>
                        `;
                    }
                    numWorkersGroup.style.display = parallelIngestionCheckbox.checked ? 'block' : 'none';
                    break;
                case 'db':
                    fieldsHtml = `
                        <div class="form-group">
                            <label for="dbConnectionString">Database Connection String:</label>
                            <input type="text" id="dbConnectionString" name="dbConnectionString" placeholder="e.g., sqlite:///data.db or postgresql://user:pass@host:port/dbname" required>
                            <p class="info">This must be a connection string configured in your server's .ragnetic/config.ini or .env.</p>
                        </div>
                    `;
                    break;
                case 'code_repository':
                    fieldsHtml = `
                        <div class="form-group">
                            <label for="repoPath">Repository URL or Local Path:</label>
                            <input type="text" id="repoPath" name="repoPath" placeholder="e.g., https://github.com/org/repo.git or /local/path/to/repo" required>
                            <p class="info">For local paths, ensure it's within allowed data directories.</p>
                        </div>
                    `;
                    numWorkersGroup.style.display = parallelIngestionCheckbox.checked ? 'block' : 'none';
                    break;
                case 'gdoc':
                    fieldsHtml = `
                        <div class="form-group">
                            <label for="gdocFolderId">Google Drive Folder ID (optional):</label>
                            <input type="text" id="gdocFolderId" name="gdocFolderId" placeholder="Folder ID">
                        </div>
                        <div class="form-group">
                            <label for="gdocDocumentIds">Google Drive Document IDs (comma-separated, optional):</label>
                            <input type="text" id="gdocDocumentIds" name="gdocDocumentIds" placeholder="doc_id1,doc_id2">
                        </div>
                        <div class="form-group">
                            <label for="gdocFileTypes">File Types (comma-separated, optional, e.g., 'document', 'spreadsheet'):</label>
                            <input type="text" id="gdocFileTypes" name="gdocFileTypes" placeholder="document,spreadsheet">
                            <p class="info">Ensure Google Drive API credentials are configured on the server ('ragnetic auth gdrive').</p>
                        </div>
                    `;
                    break;
                case 'api':
                    fieldsHtml = `
                        <div class="form-group">
                            <label for="apiUrl">API Endpoint URL:</label>
                            <input type="url" id="apiUrl" name="apiUrl" required>
                        </div>
                        <div class="form-group">
                            <label for="apiMethod">Method:</label>
                            <select id="apiMethod" name="apiMethod">
                                <option value="GET">GET</option>
                                <option value="POST">POST</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="apiHeaders">Headers (JSON string, optional):</label>
                            <textarea id="apiHeaders" name="apiHeaders" rows="3" placeholder='{"Authorization": "Bearer token"}'></textarea>
                        </div>
                        <div class="form-group">
                            <label for="apiParams">Parameters (JSON string for GET, optional):</label>
                            <textarea id="apiParams" name="apiParams" rows="3" placeholder='{"query": "value"}'></textarea>
                        </div>
                        <div class="form-group">
                            <label for="apiPayload">Payload (JSON string for POST, optional):</label>
                            <textarea id="apiPayload" name="apiPayload" rows="5" placeholder='{"data": "value"}'></textarea>
                        </div>
                        <div class="form-group">
                            <label for="jsonPointer">JSON Pointer (optional, e.g., '/items/0'):</label>
                            <input type="text" id="jsonPointer" name="jsonPointer" placeholder="/path/to/records">
                            <p class="info">JSON Pointer extracts specific data from the API response.</p>
                        </div>
                    `;
                    break;
                default:
                    fieldsHtml = `<p class="info-msg">Select a source type to configure its specific ingestion options.</p>`;
            }
            ingestionSourceFieldsDiv.innerHTML = fieldsHtml;
        }

        // Ingestion form submission
        ingestionForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            ingestionStatusMessagesDiv.innerHTML = '<p class="info-msg">Ingestion process started:</p>'; // Clear and reset
            ingestionProgressBar.style.width = '0%';
            ingestionProgressBar.textContent = '';
            startIngestionBtn.disabled = true;
            startIngestionBtn.textContent = "Ingesting...";

            const selectedAgentName = ingestionAgentNameSelect.value;
            const sourceType = ingestionSourceTypeSelect.value;
            const reproducibleIds = document.getElementById('reproducibleIds').checked;
            const parallelIngestion = parallelIngestionCheckbox.checked;
            const numIngestionWorkers = numIngestionWorkersInput.value ? parseInt(numIngestionWorkersInput.value) : undefined;

            let sourcesToAdd = []; // This will hold the new source objects for the agent config

            try {
                if (!loggedInUserToken || !loggedInDbUserId) {
                    throw new Error('Not authenticated. Please log in.');
                }
                if (!selectedAgentName) {
                    throw new Error('Please select an agent.');
                }

                if (sourceType === 'local_upload') {
                    const files = document.getElementById('fileInput').files;
                    if (files.length === 0) throw new Error('No files selected for upload.');

                    addIngestionStatusMessage(`Uploading ${files.length} file(s)...`, 'info');
                    // Reset progress for new upload attempt
                    ingestionProgressBar.style.width = '0%';
                    ingestionProgressBar.textContent = '';

                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const formData = new FormData();
                        formData.append('file', file);

                        // Simulate progress for local file upload (client-side only)
                        const xhr = new XMLHttpRequest();
                        xhr.open('POST', `${API_BASE_URL}/agents/upload-file`, true); // Corrected URL
                        xhr.setRequestHeader('X-API-Key', loggedInUserToken);

                        xhr.upload.onprogress = (e) => {
                            if (e.lengthComputable) {
                                const percentComplete = (e.loaded / e.total) * 100;
                                ingestionProgressBar.style.width = percentComplete + '%';
                                ingestionProgressBar.textContent = `Uploading: ${percentComplete.toFixed(0)}%`;
                            }
                        };

                        const uploadPromise = new Promise((resolve, reject) => {
                            xhr.onload = () => {
                                if (xhr.status >= 200 && xhr.status < 300) {
                                    resolve(JSON.parse(xhr.responseText));
                                } else {
                                    let errorDetail = xhr.responseText;
                                    try { errorDetail = JSON.parse(xhr.responseText).detail; } catch (e) {}
                                    reject(new Error(`Server responded with status ${xhr.status}: ${errorDetail || xhr.statusText}`));
                                }
                            };
                            xhr.onerror = () => reject(new Error('Network error during file upload.'));
                            xhr.send(formData);
                        });

                        const uploadResult = await uploadPromise;
                        sourcesToAdd.push({ type: 'local', path: uploadResult.file_path }); // Convert uploaded path to 'local' source type
                        addIngestionStatusMessage(`Uploaded '${file.name}' to '${uploadResult.file_path}'`, 'success');
                    }
                    ingestionProgressBar.textContent = 'Uploads Complete!';
                    ingestionProgressBar.style.width = '100%';
                } else {
                    // For other source types, gather data as a single source object
                    let newSource = {};
                    switch (sourceType) {
                        // Removed specific file types from this switch statement
                        case 'local':
                            const filePath = document.getElementById('filePath').value;
                            if (!filePath) throw new Error('File Path is required.');
                            newSource = { type: sourceType, path: filePath };
                            break;
                        case 'url':
                        case 'web_crawler':
                            const urlPath = document.getElementById('urlPath').value;
                            const maxDepth = document.getElementById('maxDepth') ? parseInt(document.getElementById('maxDepth').value) : undefined;
                            if (!urlPath) throw new Error('URL is required.');
                            newSource = { type: sourceType, url: urlPath };
                            if (sourceType === 'web_crawler' && maxDepth !== undefined) {
                                newSource.max_depth = maxDepth;
                            }
                            break;
                        case 'db':
                            const dbConnectionString = document.getElementById('dbConnectionString').value;
                            if (!dbConnectionString) throw new Error('Database connection string is required.');
                            newSource = { type: 'db', db_connection: dbConnectionString };
                            break;
                        case 'code_repository':
                            const repoPath = document.getElementById('repoPath').value;
                            if (!repoPath) throw new Error('Repository path is required.');
                            newSource = { type: 'code_repository', path: repoPath };
                            break;
                        case 'gdoc':
                            const gdocFolderId = document.getElementById('gdocFolderId').value;
                            const gdocDocumentIds = document.getElementById('gdocDocumentIds').value;
                            const gdocFileTypes = document.getElementById('gdocFileTypes').value;
                            if (!gdocFolderId && !gdocDocumentIds) throw new Error('Either Folder ID or Document IDs are required for Google Drive.');
                            newSource = {
                                type: 'gdoc',
                                folder_id: gdocFolderId || undefined,
                                document_ids: gdocDocumentIds ? gdocDocumentIds.split(',').map(id => id.trim()) : undefined,
                                file_types: gdocFileTypes ? gdocFileTypes.split(',').map(type => type.trim()) : undefined
                            };
                            break;
                        case 'api':
                            const apiUrl = document.getElementById('apiUrl').value;
                            const apiMethod = document.getElementById('apiMethod').value;
                            const apiHeaders = document.getElementById('apiHeaders').value;
                            const apiParams = document.getElementById('apiParams').value;
                            const apiPayload = document.getElementById('apiPayload').value;
                            const jsonPointer = document.getElementById('jsonPointer').value;
                            if (!apiUrl) throw new Error('API URL is required.');
                            newSource = {
                                type: 'api',
                                url: apiUrl,
                                method: apiMethod,
                                headers: apiHeaders ? JSON.parse(apiHeaders) : undefined,
                                params: apiParams ? JSON.parse(apiParams) : undefined,
                                payload: apiPayload ? JSON.parse(apiPayload) : undefined,
                                json_pointer: jsonPointer || undefined
                            };
                            break;
                        default:
                            throw new Error('Unsupported source type selected.');
                    }
                    sourcesToAdd.push(newSource);
                }

                // Fetch existing agent config to merge new source
                const existingAgentResponse = await fetch(`${API_BASE_URL}/agents/${selectedAgentName}`, {
                    headers: { 'X-API-Key': loggedInUserToken }
                });
                if (!existingAgentResponse.ok) {
                    const errorData = await existingAgentResponse.json();
                    throw new Error(`Failed to fetch existing agent config: ${errorData.detail || existingAgentResponse.statusText}`);
                }
                const existingAgentConfig = await existingAgentResponse.json();

                // Construct the updated agent config payload
                // Use a deep clone and then carefully merge/overwrite
                let agentConfigPayload = JSON.parse(JSON.stringify(existingAgentConfig)); // Deep clone to avoid mutating original or losing nested objects

                // Overwrite specific fields that can be changed via this modal
                agentConfigPayload.reproducible_ids = reproducibleIds;
                agentConfigPayload.scaling = {
                    parallel_ingestion: parallelIngestion,
                    num_ingestion_workers: numIngestionWorkers
                };

                // Merge sources, ensuring no duplicates based on type and identifier
                const mergedSources = [];
                const existingSourcesMap = new Map();

                // Add existing sources to map and merged list
                (existingAgentConfig.sources || []).forEach(src => {
                    const identifier = src.path || src.url || src.db_connection;
                    if (identifier) {
                        existingSourcesMap.set(`${src.type}-${identifier}`, src);
                    }
                    mergedSources.push(src); // Add all existing sources first
                });

                // Add new sources, avoiding duplicates
                sourcesToAdd.forEach(newSrc => {
                    const identifier = newSrc.path || newSrc.url || newSrc.db_connection;
                    if (identifier && !existingSourcesMap.has(`${newSrc.type}-${identifier}`)) {
                        mergedSources.push(newSrc);
                    } else if (identifier) {
                        addIngestionStatusMessage(`Warning: Source '${newSrc.type}' with identifier '${identifier}' already exists. Skipping addition.`, 'warn');
                    }
                });
                agentConfigPayload.sources = mergedSources;

                // Send the API request to trigger ingestion
                addIngestionStatusMessage(`Sending ingestion request to backend for agent '${selectedAgentName}'...`, 'info');
                const response = await fetch(`${API_BASE_URL}/agents/${selectedAgentName}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': loggedInUserToken
                    },
                    body: JSON.stringify(agentConfigPayload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API request to trigger ingestion failed: ${errorData.detail || response.statusText}`);
                }

                const result = await response.json();
                addIngestionStatusMessage(`Ingestion triggered successfully for agent '${selectedAgentName}'. Status: ${result.status}.`, 'success');
                ingestionProgressBar.style.width = '100%';
                ingestionProgressBar.textContent = 'Ingestion Triggered!';

            } catch (error) {
                addIngestionStatusMessage(`Ingestion process error: ${error.message}`, 'error');
                console.error('Ingestion process error:', error);
                ingestionProgressBar.style.width = '0%'; // Reset progress on failure
                ingestionProgressBar.textContent = '';
                startIngestionBtn.disabled = false;
                startIngestionBtn.textContent = "Start Ingestion";
            }
        });

    </script>
</body>
</html>